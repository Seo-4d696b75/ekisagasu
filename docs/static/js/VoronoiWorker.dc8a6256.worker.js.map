{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","diagram/types.ts","diagram/utils.ts","diagram/Point.ts","diagram/Edge.ts","diagram/Line.ts","diagram/Voronoi.ts","diagram/Triangle.ts","script/VoronoiWorker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","runtime","undefined","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelper","allowArrayLike","it","isArray","minLen","from","test","F","e","_e","f","normalCompletion","didErr","step","_e2","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","_defineProperties","target","props","descriptor","_createClass","Constructor","protoProps","staticProps","_classCallCheck","instance","_setPrototypeOf","_inherits","subClass","superClass","_getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","_typeof","_possibleConstructorReturn","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","Super","NewTarget","Parent","Class","a","_cache","Map","indexOf","has","set","Wrapper","DiagramError","ObjectSet","comparator","hash","collection","compare","map","element","add","tmp","entries","pair","list","every","some","delete","removed","filter","size","clear","consumer","predicate","ZERO","x","y","Number","isFinite","PointInitError","init","digit","isInteger","toFixed","isPoint","equals","p1","p2","hashCode","point","str","charCodeAt","stringHash","isEdge","b","toLine","edge","line","LineInitError","LineError","mes","getIntersection","l1","l2","det","VoronoiError","invert","ERROR","Math","pow","Node","_p1","_p2","index","onBoundary","cnt","isBoundary","previous","hasNext","calcNext","hasPrevious","current","other","forward","node","neighbor","isNeighbor","hasNeighbor","t1","t2","level","onSolved","round","Intersection","intersection","center","_previous","_node","dx","dy","incrementIndex","onIntersectionSolved","release","Bisector","bisector","intersections","delaunayPoint","solvedPointIndexFrom","MAX_SAFE_INTEGER","solvedPointIndexTo","boundary","addIntersection","min","max","addIntersectionAt","insert","splice","indexFrom","indexTo","mid","floor","Voronoi","frame","provider","container","running","targetLevel","time","callback","bisectors","requestedPoint","addedPoint","performance","now","addBoundary","neighbors","addBisector","searchPolygon","loopTime","promise","traverse","all","console","log","nextLevel","tasks","nextUp","hasSolved","history","sample","nextDown","start","requestExtension","task","preexist","triangle","x1","y1","x2","y2","x3","y3","v1","v2","v3","ctx","voronoi","addEventListener","messaage","data","JSON","parse","code","postMessage","stringify","execute","k","polygon","lat","lng","catch","message","points"],"mappings":"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","file":"static/js/VoronoiWorker.dc8a6256.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/ekisagasu/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","\r\nexport interface Point {\r\n\tx: number\r\n\ty: number\r\n}\r\n\r\n\r\nexport interface Line {\r\n\ta: number\r\n\tb: number\r\n\tc: number\r\n}\r\n\r\n\r\nexport interface Edge {\r\n\ta: Point\r\n\tb: Point\r\n}\r\n\r\n\r\nexport interface Triangle {\r\n\ta: Point\r\n\tb: Point\r\n\tc: Point\r\n}\r\n\r\n\r\nexport interface Circle {\r\n\tcenter: Point\r\n\tradius: number\r\n}\r\n\r\nexport interface Rect {\r\n  left: number\r\n  top: number\r\n  right: number\r\n  bottom: number\r\n}\r\n\r\n\r\nexport class DiagramError extends Error {}","\n\nexport function stringHash(str: string): number {\n\t// https://stackoverflow.com/questions/194846/is-there-any-kind-of-hash-code-function-in-javascript\n\t// https://github.com/darkskyapp/string-hash/blob/master/index.js\n\tvar hash = 5381;\n\tif (typeof str === \"string\") {\n\t\tvar i = str.length - 1;\n\t\twhile (i >= 0) {\n\t\t\thash = (hash * 33) ^ str.charCodeAt(i);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn hash & hash;\n}\n\ntype Comparator<E> = (obj1: E, obj2: E) => boolean\ntype HashGetter<E> = (e: E) => number\n\n/**\n * primitiveObject\n * comparator\n * hash\n * comparator(obj1,obj2) === true  hash(obj1) === hash(obj2) \n * \"===\"primitive\n * \n * hash(obj1) === hash(obj2)  comparator(obj1,obj2) === false \n */\nexport class ObjectSet<E> {\n\n\t/**\n\t * \n\t * @param {(obj1,obj2) => boolean} comparator \n\t * @param {(obj) => hashCode} hash \n\t * @param {iterable} collection \n\t */\n\tconstructor(comparator: Comparator<E>, hash: HashGetter<E>, collection?: Array<E>) {\n\t\tthis.compare = comparator;\n\t\tthis.hash = hash;\n\t\tthis.map = new Map();\n\t\tif (collection) {\n\t\t\tcollection.forEach(element => {\n\t\t\t\tthis.add(element);\n\t\t\t});\n\t\t}\n\t}\n\n\tcompare: Comparator<E>\n\thash: HashGetter<E>\n\tmap: Map<number, Array<E>>\n\n\tclone() {\n\t\tvar tmp = new ObjectSet<E>(this.compare, this.hash);\n\t\tfor (let pair of this.map.entries()) {\n\t\t\tvar key: number = pair[0];\n\t\t\tvar list = pair[1];\n\t\t\ttmp.map.set(key, Array.from(list));\n\t\t}\n\t\treturn tmp;\n\t}\n\n\t/**\n\t * \n\t * @param {*} e \n\t * @return {boolean} true, false otherwise\n\t */\n\tadd(e: E): boolean {\n\t\tvar hash = this.hash(e);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.every(element => !this.compare(element, e))) {\n\t\t\t\tlist.push(e);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else {\n\t\t\tlist = [e];\n\t\t\tthis.map.set(hash, list);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {*} e \n\t */\n\thas(e: E): boolean {\n\t\tvar list = this.map.get(this.hash(e));\n\t\treturn !!list && list.some(element => this.compare(element, e));\n\t}\n\n\t/**\n\t * \n\t * @param {*} e \n\t * @return {boolean} true, false otherwise\n\t */\n\tremove(e: E): boolean {\n\t\tvar hash = this.hash(e);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.length === 1 && this.compare(list[0], e)) {\n\t\t\t\tthis.map.delete(hash);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar removed = list.filter(element => !this.compare(element, e));\n\t\t\tif (list.length === removed.length) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis.map.set(hash, removed);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tsize(): number {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tsize += list.length;\n\t\t}\n\t\treturn size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => void} consumer \n\t */\n\tforEach(consumer: (e: E) => void): void {\n\t\tfor (let value of this) {\n\t\t\tconsumer(value);\n\t\t}\n\t}\n\n\t*[Symbol.iterator]() {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let value of list) {\n\t\t\t\tsize += 1;\n\t\t\t\tyield value;\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => boolean} predicate \n\t */\n\tfilter(predicate: (e: E) => boolean): ObjectSet<E> {\n\t\tvar tmp = new ObjectSet(this.compare, this.hash);\n\t\tfor (let element of this) {\n\t\t\tif (predicate(element)) tmp.add(element);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => boolean} predicate \n\t */\n\tremoveIf(predicate: (e: E) => boolean): ObjectSet<E> {\n\t\tvar tmp = new ObjectSet(this.compare, this.hash);\n\t\tfor (let element of this) {\n\t\t\tif (!predicate(element)) tmp.add(element);\n\t\t}\n\t\treturn tmp;\n\t}\n}\n\ntype MapEntry<K, V> = {\n\tkey: K,\n\tvalue: V | null\n}\n\nexport class ObjectMap<K, V> {\n\n\tconstructor(comparator: Comparator<K>, hash: HashGetter<K>) {\n\t\tthis.compare = comparator;\n\t\tthis.hash = hash;\n\t\tthis.map = new Map();\n\t}\n\n\tcompare: Comparator<K>\n\thash: HashGetter<K>\n\tmap: Map<number, Array<MapEntry<K, V>>>\n\n\tput(key: K, value: V | null): void {\n\t\tvar hash = this.hash(key);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\t\tif (index < 0) {\n\t\t\t\tvar pair: MapEntry<K, V> = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value\n\t\t\t\t}\n\t\t\t\tlist.push(pair);\n\t\t\t} else {\n\t\t\t\tlist[index].value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tlist = [\n\t\t\t\t{\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value\n\t\t\t\t}\n\t\t\t];\n\t\t\tthis.map.set(hash, list);\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\tvar list = this.map.get(this.hash(key));\n\t\treturn !!list && list.some(pair => this.compare(pair.key, key));\n\t}\n\n\tget(key: K, defaultValue?: V | null): V | null {\n\t\tvar list = this.map.get(this.hash(key));\n\t\tif (!list) return null;\n\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\tif (index < 0) {\n\t\t\tif ( defaultValue ) return defaultValue\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn list[index].value;\n\t\t}\n\t}\n\n\tgetValue(key: K): V {\n\t\tvar value = this.get(key)\n\t\tif ( value ) return value\n\t\tthrow new Error(`no such element. key:${key}`)\n\t}\n\n\t/**\n\t * keyvalue\n\t * @param {*} key \n\t * @return {obj} value, null\n\t */\n\tremove(key: K): V | null {\n\t\tvar hash = this.hash(key);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.length === 1 && this.compare(list[0].key, key)) {\n\t\t\t\tthis.map.delete(hash);\n\t\t\t\treturn list[0].value;\n\t\t\t}\n\t\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\t\tif (index < 0) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tvar value = list[index].value;\n\t\t\t\tvar removed = list.filter(pair => !this.compare(pair.key, key));\n\t\t\t\tthis.map.set(hash, removed);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tsize(): number {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tsize += list.length;\n\t\t}\n\t\treturn size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\t/**\n\t * \n\t * @param {(key) => void} consumer \n\t */\n\tforEachKey(consumer: (key: K) => void) {\n\t\tfor (let key of this.keys()) {\n\t\t\tconsumer(key);\n\t\t}\n\t}\n\n\t* keys() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tyield entry.key;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {(value) => void} consumer \n\t */\n\tforEachValue(consumer: (value: V | null) => void) {\n\t\tfor (let value of this.values()) {\n\t\t\tconsumer(value);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tyield entry.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {(entry: {key:any, value:any}) => void} consumer \n\t */\n\tforEachEntries(consumer: (e: MapEntry<K, V>) => void) {\n\t\tfor (let entry of this.entries()) {\n\t\t\tconsumer(entry);\n\t\t}\n\t}\n\n\t* entries() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tvar tmp = {\n\t\t\t\t\tkey: entry.key,\n\t\t\t\t\tvalue: entry.value\n\t\t\t\t};\n\t\t\t\tyield tmp;\n\t\t\t}\n\t\t}\n\t}\n\n}","import { stringHash } from \"./utils\"\nimport {Point, DiagramError} from \"./types\"\n\nexport const ZERO: Point = init(0, 0)\n\nclass PointInitError extends DiagramError {\n\tconstructor(x: number, y: number) {\n\t\tsuper(`cannot get an instance with x:${x} y:${y}`)\n\t}\n}\n\nexport function toString(p: Point, digit?: number) {\n\tif (digit && Number.isInteger(digit) && digit > 0) {\n\t\treturn `(${p.x.toFixed(digit)},${p.y.toFixed(digit)})`\n\t}\n\treturn `(${p.x},${p.y})`\n}\n\nexport function isPoint(p: any): p is Point {\n\treturn p !== null && typeof p === \"object\" && typeof p.x === \"number\" && typeof p.y === \"number\"\n}\n\nexport function init(x: number, y: number): Point {\n\tif (Number.isFinite(x) && Number.isFinite(y)) {\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t}\n\t}\n\tthrow new PointInitError(x, y)\n}\n\nexport function equals(p1: Point, p2: Point): boolean {\n\treturn p1.x === p2.x && p1.y === p2.y\n}\n\nexport function hashCode(point: Point): number {\n\tvar str = `${point.x.toString()},${point.y.toString}`\n\treturn stringHash(str)\n}\n\nexport function getDivision(p1: Point, p2: Point, index: number): Point {\n\treturn {\n\t\tx: p1.x * (1.0 - index) + p2.x * index,\n\t\ty: p1.y * (1.0 - index) + p2.y * index,\n\t}\n}\n\nexport function measure(p1: Point, p2: Point): number {\n\treturn Math.sqrt(\n\t\tMath.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)\n\t)\n}\n\nexport function getMiddlePoint(p1: Point, p2: Point): Point {\n\treturn {\n\t\tx: (p1.x + p2.x) / 2,\n\t\ty: (p1.y + p2.y) / 2,\n\t}\n}\n\nexport function compare(p1: Point, p2: Point): number {\n\tif (p1.x === p2.x) {\n\t\tif (p1.y === p2.y) {\n\t\t\treturn 0\n\t\t} else if (p1.y < p2.y) {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 1\n\t\t}\n\t} else if (p1.x < p2.x) {\n\t\treturn -1\n\t} else {\n\t\treturn 1\n\t}\n}","import * as line from \"./Line\";\nimport * as point from \"./Point\";\nimport {Point, Line, Edge, DiagramError} from \"./types\"\n\nexport function toString(e: Edge) {\n\treturn `{${point.toString(e.a)}-${point.toString(e.b)}}`\n}\n\nexport function isEdge(p: any): p is Edge {\n\treturn p !== null &&\n\t\ttypeof p === \"object\" &&\n\t\tpoint.isPoint(p.a) &&\n\t\tpoint.isPoint(p.b)\n\n}\n\nclass EdgeError extends DiagramError {}\n\nclass EdgeInitError extends DiagramError {\n\tconstructor(p: Point) {\n\t\tsuper(`point duplicated: ${point.toString(p)}`)\n\t}\n}\n\nexport function init(a: Point, b: Point): Edge {\n\tif (a.x < b.x) {\n\t\treturn { a: a, b: b };\n\t} else if (a.x > b.x) {\n\t\treturn { a: b, b: a };\n\t} else {\n\t\tif (a.y < b.y) {\n\t\t\treturn { a: a, b: b };\n\t\t} else if (a.y > b.y) {\n\t\t\treturn { a: b, b: a };\n\t\t} else {\n\t\t\tthrow new EdgeInitError(a)\n\t\t}\n\t}\n}\n\nexport function toLine(edge: Edge): Line {\n\treturn line.init(edge.a, edge.b);\n}\n\nexport function equals(self: Edge, other: Edge): boolean {\n\treturn point.equals(self.a, other.a) && point.equals(self.b, other.b);\n}\n\nexport function hashCode(edge: Edge): number {\n\tvar hash = 17;\n\thash = 31 * hash + point.hashCode(edge.a);\n\thash = 31 * hash + point.hashCode(edge.b);\n\treturn hash & hash;\n}\n\nexport function getMiddlepoint(edge: Edge): Point {\n\treturn {\n\t\tx: (edge.a.x + edge.b.x) / 2,\n\t\ty: (edge.a.y + edge.b.y) / 2,\n\t};\n}\n\nexport function onEdge(p1: Edge | Point, p2: Point, p3?: Point): boolean {\n\tif (isEdge(p1)) {\n\t\tp3 = p2\n\t\tvar edge = p1\n\t\tp1 = edge.a\n\t\tp2 = edge.b\n\t}\n\tif (p3) {\n\t\tvar start: Point = p1\n\t\tvar end: Point = p2\n\t\tvar p: Point = p3\n\t\tif ((start.x - p.x) * (end.x - p.x) + (start.y - p.y) * (end.y - p.y) <= 0) {\n\t\t\treturn line.onLine(start, end, p);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tthrow new EdgeError(\"invalid arguments\")\n}\n\nexport function getDivision(edge: Edge, index: number): Point {\n\treturn point.getDivision(edge.a, edge.b, index);\n}\n\n/**\n * \n * @param {edge} edge \n * @param {edge/line} other \n * @return null if no such point\n */\nexport function getIntersection(edge: Edge, other: Edge | Line): Point | null {\n\tif (line.isLine(other)) {\n\t\tvar p = line.getIntersection(toLine(edge), other);\n\t\tif (p) {\n\t\t\tvar v = (edge.a.x - p.x) * (edge.b.x - p.x) + (edge.a.y - p.y) * (edge.b.y - p.y);\n\t\t\treturn v <= 0 ? p : null;\n\t\t}\n\t\treturn null\n\t} else {\n\t\tp = getIntersection(edge, toLine(other));\n\t\tif (p) {\n\t\t\tv = (other.a.x - p.x) * (other.b.x - p.x) + (other.a.y - p.y) * (other.b.y - p.y);\n\t\t\tif (v <= 0) return p;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport function getDistance(edge: Edge, p: Point): number {\n\tvar v1 = (p.x - edge.a.x) * (edge.b.x - edge.a.x) + (p.y - edge.a.y) * (edge.b.y - edge.a.y);\n\tvar v2 = (p.x - edge.b.x) * (edge.a.x - edge.b.x) + (p.y - edge.b.y) * (edge.a.y - edge.b.y);\n\tif (v1 > 0 && v2 > 0) {\n\t\treturn line.getDistance(toLine(edge), p);\n\t} else if (v1 <= 0) {\n\t\treturn point.measure(edge.a, p);\n\t} else {\n\t\treturn point.measure(edge.b, p);\n\t}\n}","import * as point from \"./Point\"\nimport * as edge from \"./Edge\"\nimport {Point, Line, Edge, DiagramError} from \"./types\"\n\nclass LineInitError extends DiagramError {}\n\nclass LineError extends DiagramError {\n\tconstructor(mes: string, line?: Line) {\n\t\tsuper(line ? `${mes} line:${toString(line)}` : mes)\n\t}\n}\n\nexport function toString(line: Line): string {\n\treturn `{ax+by+c=0 with a:${line.a},b:${line.b},c:${line.c}}`\n}\n\nexport function isLine(p: any): p is Line {\n\treturn p !== null &&\n\t\ttypeof p === \"object\" &&\n\t\ttypeof p.a === \"number\" &&\n\t\ttypeof p.b === \"number\" &&\n\t\ttypeof p.c === \"number\"\n}\n\n/**\n * Gets an instance of a new line. Pairs of argments are; \n * (1) a, b, c: number => a line defined by equation: ax + by + c = 0\n * (2) a, b: Point => a line which goes through the both points\n * @param a \n * @param b \n * @param c \n */\nexport function init(a: number | Point, b: number | Point, c?: number): Line {\n\tif (typeof a === \"number\" && typeof b === \"number\") {\n\t\tif (typeof c === \"number\") {\n\t\t\tif (b === 0) {\n\t\t\t\tif (a === 0) {\n\t\t\t\t\tthrow new LineInitError(\"a = b = 0\")\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ta: 1.0,\n\t\t\t\t\tb: 0.0,\n\t\t\t\t\tc: c / a,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ta: a / b,\n\t\t\t\t\tb: 1.0,\n\t\t\t\t\tc: c / b,\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: -a,\n\t\t\t\tb: 1.0,\n\t\t\t\tc: -b,\n\t\t\t};\n\t\t}\n\t} else if (point.isPoint(a) && point.isPoint(b)) {\n\t\tif (point.equals(a, b)) {\n\t\t\tthrow new LineInitError(`duplicated point: ${point.toString(a)}`)\n\t\t} else if (a.x === b.x) {\n\t\t\treturn {\n\t\t\t\ta: 1.0,\n\t\t\t\tb: 0.0,\n\t\t\t\tc: -(a.x + b.x) / 2,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: (b.y - a.y) / (a.x - b.x),\n\t\t\t\tb: 1.0,\n\t\t\t\tc: (b.x * a.y - a.x * b.y) / (a.x - b.x),\n\t\t\t};\n\t\t}\n\t}\n\tthrow new LineInitError(`cannot get an instance with a:${a} b:${b} c:${c}`)\n}\n\n/**\n * Check if a point is located on the given line. \n * (1) a: Line, b: Point => whether point 'b' is located on line 'a' \n * (2) a: Point, b :Point, c: Point => whether point 'c' is located on a line connecting two points 'a' and 'b'\n * @param {line/point} a \n * @param {point} b \n * @param {point} c \n */\nexport function onLine(a: Line | Point, b: Point, c?: Point): boolean {\n\tif (isLine(a) && point.isPoint(b)) {\n\t\tvar line = a;\n\t\tvar p = b;\n\t\treturn Math.abs(line.a * p.x + line.b * p.y + line.c) === 0;\n\t}\n\tif (point.isPoint(a) && point.isPoint(b) && point.isPoint(c)) {\n\t\tvar v = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\t\treturn v === 0;\n\t}\n\tthrow new LineError(\"invalid arguments\")\n}\n\nexport function equals(l1: Line, l2: Line): boolean {\n\treturn l1.a === l2.a && l1.b === l2.b && l1.c === l2.c;\n}\n\nexport function getIntersection(l1: Line, l2: Line | Edge): Point | null {\n\tif (edge.isEdge(l2)) {\n\t\t// l1:Line l2:edge\n\t\tvar line = l1;\n\t\tvar e = l2;\n\t\tif ((line.a * e.a.x + line.b * e.a.y + line.c) * (line.a * e.b.x + line.b * e.b.y + line.c) <= 0) {\n\t\t\tl2 = edge.toLine(e);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\t// l1:Line l2:Line\n\tvar det = l1.a * l2.b - l2.a * l1.b;\n\tif (det === 0) {\n\t\treturn null;\n\t} else {\n\t\treturn {\n\t\t\tx: (l1.b * l2.c - l2.b * l1.c) / det,\n\t\t\ty: (l2.a * l1.c - l1.a * l2.c) / det,\n\t\t};\n\t}\n}\n\nexport function getPerpendicularBisector(p1: Point | Edge, p2?: Point): Line {\n\tif (edge.isEdge(p1)) {\n\t\t// p1:edge p2:null\n\t\tvar e = p1;\n\t\tp1 = e.a;\n\t\tp2 = e.b;\n\t}\n\tif (p2) {\n\n\t\t// p1,p2:Point\n\t\treturn {\n\t\t\ta: p1.x - p2.x,\n\t\t\tb: p1.y - p2.y,\n\t\t\tc: (-Math.pow(p1.x, 2) - Math.pow(p1.y, 2) + Math.pow(p2.x, 2) + Math.pow(p2.y, 2)) / 2,\n\t\t}\n\t}\n\tthrow new LineError(`invalid arguments p1:${p1},p2:${p2}`)\n}\n\nexport function getDistance(line: Line, point: Point): number {\n\treturn Math.abs(point.x * line.a + point.y * line.b + line.c) / Math.sqrt(line.a * line.a + line.b * line.b);\n}\n\nexport function onSameSide(line: Line, p1: Point, p2: Point): boolean {\n\tvar v1 = line.a * p1.x + line.b * p1.y + line.c;\n\tvar v2 = line.a * p2.x + line.b * p2.y + line.c;\n\treturn v1 * v2 >= 0;\n}\n","import { Point, Line, Edge, Triangle, DiagramError } from \"./types\"\r\nimport * as point from \"./Point\";\r\nimport * as line from \"./Line\";\r\nimport * as triangle from \"./Triangle\";\r\nimport { ObjectSet } from \"./utils\";\r\n\r\nclass VoronoiError extends DiagramError {\r\n\tconstructor(mes: string) {\r\n\t\tsuper(mes)\r\n\t}\r\n}\r\n\r\n/**\r\n * \r\n */\r\ntype StepDirection = \"up\" | \"zero\" | \"down\"\r\n\r\nfunction invert(step: StepDirection): StepDirection {\r\n\tswitch (step) {\r\n\t\tcase \"up\":\r\n\t\t\treturn \"down\"\r\n\t\tcase \"down\":\r\n\t\t\treturn \"up\"\r\n\t\tcase \"zero\":\r\n\t\t\treturn \"zero\"\r\n\t}\r\n}\r\n\r\nconst ERROR = Math.pow(2, -30);\r\n\r\n/**\r\n * Point +    \r\n * Bisector\r\n */\r\nclass Node implements Point {\r\n\r\n\tconstructor(p: Point, a: Intersection, b: Intersection) {\r\n\t\tthis.x = p.x;\r\n\t\tthis.y = p.y;\r\n\t\tthis._p1 = a;\r\n\t\tthis._p2 = b;\r\n\t\tvar cnt = 0;\r\n\t\tif (a.line.isBoundary) cnt++;\r\n\t\tif (b.line.isBoundary) cnt++;\r\n\t\tif (cnt === 0) {\r\n\t\t\tthis.onBoundary = false;\r\n\t\t\tthis.index = -1;\r\n\t\t} else if (cnt === 1) {\r\n\t\t\tthis.onBoundary = true;\r\n\t\t\tthis.index = -1;\r\n\t\t} else {\r\n\t\t\tthis.onBoundary = false;\r\n\t\t\tthis.index = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tx: number\r\n\ty: number\r\n\r\n\t// \r\n\t_p1: Intersection | null\r\n\t_p2: Intersection | null\r\n\r\n\tget p1(): Intersection {\r\n\t\tif (this._p1) return this._p1\r\n\t\tthrow new VoronoiError(\"no intersection\")\r\n\t}\r\n\r\n\r\n\tget p2(): Intersection {\r\n\t\tif (this._p2) return this._p2\r\n\t\tthrow new VoronoiError(\"no intersection\")\r\n\t}\r\n\r\n\tindex: number\r\n\tonBoundary: boolean\r\n\r\n\t/**\r\n\t * .\r\n\t * @param previous from which you are traversing\r\n\t * @return Node\r\n\t */\r\n\tnext(previous: Point) {\r\n\t\tconst p1 = this.p1;\r\n\t\tconst p2 = this.p2;\r\n\t\tif (p1.hasNext && point.equals(p1.next, previous)) {\r\n\t\t\treturn this.calcNext(p1, p2, false, invert(p1.step));\r\n\t\t} else if (p1.hasPrevious && point.equals(p1.previous, previous)) {\r\n\t\t\treturn this.calcNext(p1, p2, true, p1.step);\r\n\t\t} else if (p2.hasNext && point.equals(p2.next, previous)) {\r\n\t\t\treturn this.calcNext(p2, p1, false, invert(p2.step));\r\n\t\t} else if (p2.hasPrevious && point.equals(p2.previous, previous)) {\r\n\t\t\treturn this.calcNext(p2, p1, true, p2.step);\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"next node not found.\");\r\n\t\t}\r\n\t}\r\n\r\n\tcalcNext(current: Intersection, other: Intersection, forward: boolean, step: StepDirection) {\r\n\t\tif (this.onBoundary && this.index > 0) {\r\n\t\t\t// FrameVertex\r\n\t\t\t// \r\n\t\t\treturn forward ? current.next.node : current.previous.node;\r\n\t\t} else {\r\n\t\t\t// Frame step = Node.STEP_UP/DOWN\r\n\t\t\t// FrameVertex step = Node.STEP_ZERO\r\n\t\t\treturn other.neighbor(invert(step)).node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t\t\t\t * .<br>\r\n\t\t\t\t * Frame\r\n\t\t\t\t * FrameVertex0\r\n\t * @param previous \r\n\t */\r\n\tnextDown(previous: Point): Node {\r\n\t\tvar target: any = null;\r\n\t\tif (this.p1.isNeighbor(previous)) {\r\n\t\t\ttarget = this.p2;\r\n\t\t} else if (this.p2.isNeighbor(previous)) {\r\n\t\t\ttarget = this.p1;\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"neighbor not found\");\r\n\t\t}\r\n\t\tif (target.hasNeighbor(\"down\")) {\r\n\t\t\treturn target.neighbor(\"down\").node;\r\n\t\t} else {\r\n\t\t\treturn target.neighbor(\"zero\").node;\r\n\t\t}\r\n\t}\r\n\r\n\tnextUp(previous: Point): Node | null {\r\n\t\tvar t1: any = null;\r\n\t\tvar t2: any = null;\r\n\t\tif (this.p1.isNeighbor(previous)) {\r\n\t\t\tt1 = this.p2;\r\n\t\t\tt2 = this.p1;\r\n\t\t} else if (this.p2.isNeighbor(previous)) {\r\n\t\t\tt1 = this.p1;\r\n\t\t\tt2 = this.p2;\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"neighbor not found\");\r\n\t\t}\r\n\t\tif (t1.hasNeighbor(\"up\")) {\r\n\t\t\treturn t1.neighbor(\"up\").node;\r\n\t\t} else if (t2.hasNeighbor(\"up\")) {\r\n\t\t\treturn t2.neighbor(\"up\").node;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tonSolved(level: number): void {\r\n\t\tthis.p1.onSolved();\r\n\t\tthis.p2.onSolved();\r\n\t\tif (this.index < 0) {\r\n\t\t\tif (this.p1.line.isBoundary || this.p2.line.isBoundary) {\r\n\t\t\t\tthis.index = level;\r\n\t\t\t} else {\r\n\t\t\t\tthis.index = level + 0.5;\r\n\t\t\t}\r\n\t\t} else if (Math.round(this.index) !== this.index) {\r\n\t\t\tif (this.index + 0.5 !== level) throw new VoronoiError(\"index mismatch\");\r\n\t\t}\r\n\t}\r\n\r\n\thasSolved(): boolean {\r\n\t\treturn this.index >= 0;\r\n\t}\r\n\r\n\trelease() {\r\n\t\tthis._p1 = null;\r\n\t\tthis._p2 = null;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * \r\n * \r\n */\r\nclass Intersection implements Point {\r\n\r\n\tconstructor(intersection: Point, b: Bisector, other?: Line, center?: Point) {\r\n\t\tthis.line = b;\r\n\t\tthis.x = intersection.x;\r\n\t\tthis.y = intersection.y;\r\n\r\n\t\tif (other && center) {\r\n\r\n\t\t\tvar dx = b.line.b;\r\n\t\t\tvar dy = -b.line.a;\r\n\t\t\tif (dx < 0 || (dx === 0 && dy < 0)) {\r\n\t\t\t\tdx *= -1;\r\n\t\t\t\tdy *= -1;\r\n\t\t\t}\r\n\t\t\tvar p = {\r\n\t\t\t\tx: intersection.x + dx,\r\n\t\t\t\ty: intersection.y + dy\r\n\t\t\t};\r\n\t\t\tthis.step = line.onSameSide(other, p, center) ? \"down\" : \"up\";\r\n\t\t} else {\r\n\t\t\tthis.step = \"zero\";\r\n\t\t}\r\n\t}\r\n\r\n\tx: number\r\n\ty: number\r\n\tline: Bisector\r\n\tstep: StepDirection\r\n\r\n\t_previous: Intersection | null | undefined = undefined\r\n\t_next: Intersection | null | undefined = undefined\r\n\tindex: number = 0\r\n\r\n\t_node: Node | null = null\r\n\r\n\tget hasPrevious(): boolean {\r\n\t\tif (this._previous === undefined) {\r\n\t\t\tthrow new VoronoiError(\"previous not init yet\")\r\n\t\t}\r\n\t\treturn this._previous !== null\r\n\t}\r\n\r\n\tget previous(): Intersection {\r\n\t\tif (this._previous) return this._previous\r\n\t\tif (this._previous === undefined) {\r\n\t\t\tthrow new VoronoiError(\"previous not init yet\")\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"no previous\")\r\n\t}\r\n\r\n\tget hasNext(): boolean {\r\n\t\tif (this._next === undefined) {\r\n\t\t\tthrow new VoronoiError(\"next not init yet\")\r\n\t\t}\r\n\t\treturn this._next !== null\r\n\t}\r\n\r\n\tget next(): Intersection {\r\n\t\tif (this._next) return this._next\r\n\t\tif (this._next === undefined) {\r\n\t\t\tthrow new VoronoiError(\"next not init yet\")\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"no next\")\r\n\t}\r\n\r\n\tget node(): Node {\r\n\t\tif (this._node) return this._node\r\n\t\tthrow new VoronoiError(\"no node\")\r\n\t}\r\n\r\n\tset node(value: Node) {\r\n\t\tif (this._node) throw new VoronoiError(\"node already set\")\r\n\t\tthis._node = value\r\n\t}\r\n\r\n\tinsert(previous: Intersection | null, next: Intersection | null, index: number): void {\r\n\t\tthis._previous = previous;\r\n\t\tthis._next = next;\r\n\t\tif (this._previous) {\r\n\t\t\tthis._previous._next = this;\r\n\t\t}\r\n\t\tif (this._next) {\r\n\t\t\tthis._next._previous = this;\r\n\t\t\tthis._next.incrementIndex();\r\n\t\t}\r\n\t\tthis.index = index;\r\n\t}\r\n\r\n\tincrementIndex(): void {\r\n\t\tthis.index++;\r\n\t\tif (this._next) this._next.incrementIndex();\r\n\t}\r\n\r\n\tisNeighbor(p: Point): boolean {\r\n\t\treturn (this.hasNext && point.equals(this.next, p))\r\n\t\t\t|| (this.hasPrevious && point.equals(this.previous, p));\r\n\t}\r\n\r\n\thasNeighbor(step: StepDirection): boolean {\r\n\t\tif (step === \"zero\" && this.step === \"zero\") {\r\n\t\t\treturn true;\r\n\t\t} else if (step !== \"zero\" && this.step !== \"zero\") {\r\n\t\t\treturn (step === this.step) ? !!this._next : !!this._previous;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tneighbor(step: StepDirection): Intersection {\r\n\t\tif (step === \"zero\" && this.step === \"zero\") {\r\n\t\t\tif (this._previous) return this._previous;\r\n\t\t\tif (this._next) return this._next;\r\n\t\t} else if (step !== \"zero\" && this.step !== \"zero\") {\r\n\t\t\treturn (step === this.step) ? this.next : this.previous;\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"neighbor step invalid.\");\r\n\t}\r\n\r\n\tonSolved(): void {\r\n\t\tthis.line.onIntersectionSolved(this);\r\n\t}\r\n\r\n\trelease(): void {\r\n\t\tthis._previous = null;\r\n\t\tthis._next = null;\r\n\t\tif (this._node) {\r\n\t\t\tthis._node.release();\r\n\t\t\tthis._node = null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * \r\n */\r\nclass Bisector {\r\n\r\n\tconstructor(bisector: Line, p?: Point) {\r\n\t\tthis.line = bisector;\r\n\t\tthis.intersections = [];\r\n\t\tif (p) {\r\n\t\t\tthis.delaunayPoint = p;\r\n\t\t\tthis.isBoundary = false;\r\n\t\t} else {\r\n\t\t\tthis.delaunayPoint = null;\r\n\t\t\tthis.isBoundary = true;\r\n\t\t}\r\n\t}\r\n\r\n\tline: Line\r\n\tintersections: Array<Intersection>\r\n\tisBoundary: boolean\r\n\tdelaunayPoint: Point | null\r\n\r\n\tsolvedPointIndexFrom: number = Number.MAX_SAFE_INTEGER\r\n\tsolvedPointIndexTo: number = -1\r\n\r\n\t/**\r\n\t * \r\n\t * @param boundary\r\n\t */\r\n\tinspectBoundary(boundary: Edge): void {\r\n\t\tvar p = line.getIntersection(this.line, boundary);\r\n\t\tif (p) {\r\n\t\t\tvar i = new Intersection(p, this)\r\n\t\t\tthis.addIntersection(i);\r\n\t\t}\r\n\t}\r\n\r\n\tonIntersectionSolved(intersection: Intersection): void {\r\n\t\tvar index = intersection.index;\r\n\t\tthis.solvedPointIndexFrom = Math.min(\r\n\t\t\tthis.solvedPointIndexFrom,\r\n\t\t\tindex\r\n\t\t);\r\n\t\tthis.solvedPointIndexTo = Math.max(\r\n\t\t\tthis.solvedPointIndexTo,\r\n\t\t\tindex\r\n\t\t);\r\n\t}\r\n\r\n\taddIntersection(intersection: Intersection): void {\r\n\t\tconst size = this.intersections.length;\r\n\t\tvar index = this.addIntersectionAt(intersection, 0, size);\r\n\t\tintersection.insert(\r\n\t\t\tindex > 0 ? this.intersections[index - 1] : null,\r\n\t\t\tindex < size ? this.intersections[index] : null,\r\n\t\t\tindex\r\n\t\t);\r\n\t\tthis.intersections.splice(index, 0, intersection);\r\n\t\tif (this.solvedPointIndexFrom < this.solvedPointIndexTo) {\r\n\t\t\tif (index <= this.solvedPointIndexFrom) {\r\n\t\t\t\tthis.solvedPointIndexFrom++;\r\n\t\t\t\tthis.solvedPointIndexTo++;\r\n\t\t\t} else if (index <= this.solvedPointIndexTo) {\r\n\t\t\t\tthrow new VoronoiError(\"new intersection added to solved range.\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddIntersectionAt(p: Point, indexFrom: number, indexTo: number): number {\r\n\t\tif (indexFrom === indexTo) {\r\n\t\t\treturn indexFrom;\r\n\t\t} else {\r\n\t\t\tvar mid = Math.floor((indexFrom + indexTo - 1) / 2);\r\n\t\t\tvar r = point.compare(p, this.intersections[mid]);\r\n\t\t\tif (r < 0) {\r\n\t\t\t\treturn this.addIntersectionAt(p, indexFrom, mid);\r\n\t\t\t} else if (r > 0) {\r\n\t\t\t\treturn this.addIntersectionAt(p, mid + 1, indexTo);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VoronoiError(\"same point already added in this bisector\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trelease(): void {\r\n\t\tthis.intersections.forEach(i => i.release());\r\n\t\tthis.intersections.splice(0, this.intersections.length)\r\n\t}\r\n\r\n}\r\n\r\n/** \r\n * \r\n */\r\nexport type PointProvider = (p: Point) => Promise<Array<Point>>\r\n\r\n/**\r\n * \r\n * @param index \r\n * @param polygon \r\n */\r\nexport type Callback = (index: number, polygon: Array<Point>) => void\r\n\r\n/**\r\n * \r\n */\r\nexport class Voronoi {\r\n\r\n\t/**\r\n\t * \r\n\t * @param {triangle} frame \r\n\t * @param {(point)=>Promise<array>} provider \r\n\t */\r\n\tconstructor(frame: Triangle, provider: PointProvider) {\r\n\t\tthis.container = frame;\r\n\t\tthis.provider = provider;\r\n\t}\r\n\r\n\tcontainer: Triangle\r\n\tprovider: PointProvider\r\n\trunning: boolean = false\r\n\r\n\t/**\r\n\t * \r\n\t * \r\n\t * \r\n\t * @param {number} level \r\n\t * @param {point} center \r\n\t * @param {(index: number,polygon: array)=>void} callback \r\n\t * @return 1..indexPromise\r\n\t */\r\n\tasync execute(level: number, center: Point, callback: Callback | null): Promise<Array<Array<Point>>> {\r\n\t\tif (this.running) return Promise.reject(\"already running\");\r\n\t\tthis.running = true;\r\n\r\n\t\ttry {\r\n\r\n\t\t\tthis.center = center;\r\n\t\t\tthis.level = level;\r\n\t\t\tthis.targetLevel = 1;\r\n\t\t\tthis.list = null;\r\n\t\t\tthis.time = performance.now();\r\n\t\t\tthis.result = [];\r\n\t\t\tthis.callback = callback;\r\n\t\t\tthis.bisectors = [];\r\n\t\t\tthis.addBoundary(line.init(this.container.a, this.container.b));\r\n\t\t\tthis.addBoundary(line.init(this.container.b, this.container.c));\r\n\t\t\tthis.addBoundary(line.init(this.container.c, this.container.a));\r\n\t\t\tthis.requestedPoint = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tthis.addedPoint = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tthis.requestedPoint.add(center);\r\n\t\t\tthis.addedPoint.add(center);\r\n\t\t\tconst neighbors = await this.provider(center);\r\n\t\t\tfor (let p of neighbors) {\r\n\t\t\t\tif (this.addedPoint.add(p))\r\n\t\t\t\t\tthis.addBisector(p);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e)\r\n\t\t}\r\n\t\treturn this.searchPolygon();\r\n\r\n\t}\r\n\r\n\tcenter: Point = point.ZERO\r\n\tlevel: number = 0\r\n\ttargetLevel: number = 1\r\n\tlist: Array<Node> | null = null\r\n\ttime: number = 0\r\n\tresult: Array<Array<Point>> = []\r\n\tcallback: Callback | null = null\r\n\tbisectors: Array<Bisector> = []\r\n\r\n\r\n\trequestedPoint: ObjectSet<Point> = new ObjectSet(point.equals, point.hashCode)\r\n\taddedPoint: ObjectSet<Point> = new ObjectSet(point.equals, point.hashCode)\r\n\r\n\tprivate async searchPolygon(): Promise<Array<Array<Point>>> {\r\n\t\tvar loopTime = performance.now();\r\n\t\tvar promise: Array<Promise<void>> = [];\r\n\t\tvar list = this.traverse(this.list, promise);\r\n\t\tlist.forEach(node => node.onSolved(this.targetLevel));\r\n\t\tthis.result.push(list);\r\n\t\tthis.list = list;\r\n\t\tawait Promise.all(promise);\r\n\r\n\t\tconsole.log(`execute index:${this.targetLevel} time:${performance.now() - loopTime}`);\r\n\t\tif (this.callback && this.list) {\r\n\t\t\tthis.callback(this.targetLevel - 1, this.list);\r\n\t\t}\r\n\t\tconst nextLevel = this.targetLevel + 1;\r\n\t\tif (nextLevel <= this.level) {\r\n\t\t\tthis.targetLevel = nextLevel;\r\n\t\t\treturn this.searchPolygon();\r\n\t\t} else {\r\n\t\t\tthis.bisectors.forEach(b => b.release());\r\n\t\t\tconsole.log(`execute done. time:${performance.now() - this.time}`);\r\n\r\n\t\t\tthis.running = false;\r\n\r\n\t\t\treturn this.result;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tprivate traverse(list: Array<Node> | null, tasks: Array<Promise<void>>) {\r\n\t\tvar next: Node | null = null\r\n\t\tvar previous: Node | null = null\r\n\t\tif (!list) {\r\n\t\t\tvar history = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tvar sample = this.bisectors[0];\r\n\t\t\tnext = sample.intersections[1].node;\r\n\t\t\tprevious = sample.intersections[0].node;\r\n\t\t\twhile (history.add(next)) {\r\n\t\t\t\tvar current: Node = next;\r\n\t\t\t\tnext = current.nextDown(previous);\r\n\t\t\t\tprevious = current;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tprevious = list[list.length - 1];\r\n\t\t\tfor (let n of list) {\r\n\t\t\t\tnext = n.nextUp(previous);\r\n\t\t\t\tprevious = n;\r\n\t\t\t\tif (next && !next.hasSolved()) break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!next || !previous || next.hasSolved()) {\r\n\t\t\tthrow new VoronoiError(\"fail to traverse polygon\");\r\n\t\t}\r\n\r\n\t\tvar start = next;\r\n\t\tlist = [start];\r\n\t\twhile (true) {\r\n\t\t\tthis.requestExtension(next.p1.line.delaunayPoint, tasks);\r\n\t\t\tthis.requestExtension(next.p2.line.delaunayPoint, tasks);\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current.next(previous);\r\n\t\t\tprevious = current;\r\n\t\t\tif (point.equals(start, next)) break;\r\n\t\t\tlist.push(next);\r\n\t\t}\r\n\r\n\t\treturn list;\r\n\t}\r\n\r\n\tprivate requestExtension(target: Point | null, tasks: Array<Promise<void>>): void {\r\n\t\tif (target && this.requestedPoint.add(target)) {\r\n\t\t\tvar task = this.provider(target).then(neighbors => {\r\n\t\t\t\tfor (let p of neighbors) {\r\n\t\t\t\t\tif (this.addedPoint.add(p)) {\r\n\t\t\t\t\t\tthis.addBisector(p);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\ttasks.push(task);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * @param {*} self Line \r\n\t */\r\n\tprivate addBoundary(self: Line): void {\r\n\t\tvar boundary = new Bisector(self);\r\n\t\tthis.bisectors.forEach(preexist => {\r\n\t\t\tvar p = line.getIntersection(boundary.line, preexist.line);\r\n\t\t\tif (!p) throw new VoronoiError(\"intersection not found\")\r\n\t\t\tvar a = new Intersection(p, boundary);\r\n\t\t\tvar b = new Intersection(p, preexist);\r\n\t\t\tvar n = new Node(p, a, b);\r\n\t\t\ta.node = n;\r\n\t\t\tb.node = n;\r\n\t\t\tboundary.addIntersection(a);\r\n\t\t\tpreexist.addIntersection(b);\r\n\t\t});\r\n\t\tthis.bisectors.push(boundary);\r\n\t}\r\n\r\n\tprivate addBisector(intersection: Point) {\r\n\t\tvar bisector = new Bisector(\r\n\t\t\tline.getPerpendicularBisector(intersection, this.center),\r\n\t\t\tintersection\r\n\t\t);\r\n\t\tthis.bisectors.forEach(preexist => {\r\n\t\t\tvar p = line.getIntersection(bisector.line, preexist.line);\r\n\t\t\tif (p && triangle.containsPoint(this.container, p, ERROR)) {\r\n\t\t\t\tvar a = new Intersection(p, bisector, preexist.line, this.center);\r\n\t\t\t\tvar b = new Intersection(p, preexist, bisector.line, this.center);\r\n\t\t\t\tvar n = new Node(p, a, b);\r\n\t\t\t\ta.node = n;\r\n\t\t\t\tb.node = n;\r\n\t\t\t\tbisector.addIntersection(a);\r\n\t\t\t\tpreexist.addIntersection(b);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis.bisectors.push(bisector);\r\n\t}\r\n\r\n\r\n\r\n}","import * as line from \"./Line\";\nimport * as point from \"./Point\";\nimport * as edge from \"./Edge\";\nimport * as circle from \"./Circle\";\nimport {Point, Line, Edge, Triangle, Circle, DiagramError} from \"./types\"\n\nclass TriangleInitError extends DiagramError {}\n\nexport function init(a: Edge | Point,b: Point,c?: Point): Triangle{\n\tif ( edge.isEdge(a) ){\n\t\tvar e = a;\n\t\tc = b;\n\t\tb = e.b;\n\t\ta = e.a;\n\t}\n\tif ( c ){\n\n\t\tif ( line.onLine(a,b,c) ) {\n\t\t\tthrow new TriangleInitError(`points are on the same line. a:${point.toString(a)} b:${point.toString(b)} c:${point.toString(c)}`)\n\t\t}\n\t\tvar array = [a,b,c].sort(point.compare);\n\t\treturn {\n\t\t\ta: array[0],\n\t\t\tb: array[1],\n\t\t\tc: array[2],\n\t\t};\n\t}\n\tthrow new TriangleInitError(\"invalid arguments\")\n}\n\n/**\n * \n * @param {triangle} self \n * @param {triangle} other \n */\nexport function equals(self: Triangle,other: Triangle): boolean{\n\treturn point.equals(self.a,other.a) && point.equals(self.b,other.b) && point.equals(self.c, other.c);\n}\n\nexport function hashCode(t: Triangle): number{\n\tvar hash = 17;\n\thash = 31 * hash + point.hashCode(t.a);\n\thash = 31 * hash + point.hashCode(t.b);\n\thash = 31 * hash + point.hashCode(t.c);\n\treturn hash & hash;\n}\n\n/**\n * \n * @param {triangle} triangle \n * @param {line/edge} line \n * @return {array} Point 0 <= array.length <= 3\n */\nexport function getIntersection(triangle: Triangle,ln: Line): Array<Point>{\n\tvar ab = edge.init(triangle.a, triangle.b);\n\tvar bc = edge.init(triangle.b, triangle.c);\n\tvar ca = edge.init(triangle.c, triangle.a);\n\treturn [ab,bc,ca]\n\t\t.map( e => edge.getIntersection(e, ln) )\n\t\t.filter( (p: Point | null): p is Point => p !== null )\n\t\t.sort(point.measure);\n}\n\nexport function getOppositeSide(triangle: Triangle, p: Point): Edge{\n\tif ( point.equals(triangle.a, p) ){\n\t\treturn edge.init(triangle.b, triangle.c);\n\t} else if ( point.equals(triangle.b, p) ){\n\t\treturn edge.init(triangle.c, triangle.a);\n\t} else if ( point.equals(triangle.c, p) ){\n\t\treturn edge.init(triangle.a, triangle.b);\n\t} else {\n\t\tthrow new DiagramError(\"point is not any vertex of a triangle\")\n\t}\n}\n\nexport function containsPoint(triangle: Triangle, p: Point, error: number = 0.0): boolean {\n\tvar x1 = triangle.a.x - p.x;\n\tvar y1 = triangle.a.y - p.y;\n\tvar x2 = triangle.b.x - p.x;\n\tvar y2 = triangle.b.y - p.y;\n\tvar x3 = triangle.c.x - p.x;\n\tvar y3 = triangle.c.y - p.y;\n\tvar v1 = x1 * y2 - y1 * x2;\n\tvar v2 = x2 * y3 - y2 * x3;\n\tvar v3 = x3 * y1 - y3 * x1;\n\tif ( error && error > 0 ){\n\t\treturn (v1 > -error && v2 > -error && v3 > -error ) \n\t\t\t|| (v1 < error && v2 < error && v3 < error);\n\t} else {\n\t\treturn (v1 >= 0 && v2 >= 0 && v3 >= 0) || (v1 <= 0 && v2 <= 0 && v3 <= 0);\n\n\t}\n}\n\nexport function isVertex(triangle: Triangle ,p: Point): boolean{\n\treturn point.equals(triangle.a,p) || point.equals(triangle.b,p) || point.equals(triangle.c,p);\n}\n\nexport function isEdge(triangle: Triangle, e: Edge): boolean{\n\treturn isVertex(triangle,e.a) && isVertex(triangle,e.b);\n}\n\nexport function hasSameVertex(self: Triangle, other: Triangle): boolean{\n\treturn isVertex(self, other.a) || isVertex(self, other.b) || isVertex(self, other.c);\n}\n\nexport function getCircumscribed(triangle: Triangle): Circle{\n\tconst a = triangle.a;\n\tconst b = triangle.b;\n\tconst c = triangle.c;\n\tvar cc = 2 * ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\n\tif ( cc === 0 ) {\n\t\tthrow new circle.CircleError(\"triangle too small\")\n\t}\n\t//http://tercel-sakuragaoka.blogspot.jp/2011/06/processingdelaunay_3958.html\n\tvar p = b.x * b.x - a.x * a.x + b.y * b.y - a.y * a.y;\n\tvar q = c.x * c.x - a.x * a.x + c.y * c.y - a.y * a.y;\n\tvar center = {\n\t\tx: ((c.y - a.y) * p + (a.y - b.y) * q) / cc,\n\t\ty: ((a.x - c.x) * p + (b.x - a.x) * q) / cc\n\t};\n\tvar r = point.measure(center, a);\n\treturn circle.init(center, r);\n}","import { Voronoi } from \"../diagram/Voronoi\"\r\nimport { Point } from \"../diagram/types\"\r\n\r\nconst ctx: Worker = self as any;  /* eslint-disable-line no-restricted-globals */\r\n\r\ninterface WorkerState {\r\n\tvoronoi: Voronoi | null\r\n\tpromise: Map<number, ((p: Point[]) => void)>\r\n}\r\n\r\nconst state: WorkerState = {\r\n\tvoronoi: null,\r\n\tpromise: new Map(),\r\n};\r\n\r\nctx.addEventListener('message', messaage => {\r\n\tvar data = JSON.parse(messaage.data);\r\n\tconsole.log(\"worker\", data);\r\n\tif (data.type === 'start') {\r\n\t\tvar container = data.container;\r\n\t\tvar provider = function (point) {\r\n\t\t\treturn new Promise<Point[]>((resolve, reject) => {\r\n\t\t\t\tstate.promise.set(point.code, resolve);\r\n\t\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\t\ttype: 'points',\r\n\t\t\t\t\tcode: point.code,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\t\t};\r\n\t\tvar progress = (index: number, polygon: Point[]) => {\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'progress',\r\n\t\t\t\tindex: index,\r\n\t\t\t\tpolygon: polygon.map(point => {\r\n\t\t\t\t\treturn { lat: point.y, lng: point.x };\r\n\t\t\t\t})\r\n\t\t\t}));\r\n\t\t}\r\n\t\tstate.voronoi = new Voronoi(container, provider);\r\n\t\tstate.voronoi.execute(data.k, data.center, progress).then(() => {\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'complete',\r\n\t\t\t}));\r\n\t\t}).catch(e => {\r\n\t\t\tconsole.log(e)\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'error',\r\n\t\t\t\terr: e.message\r\n\t\t\t}));\r\n\t\t})\r\n\r\n\r\n\t} else if (data.type === 'points') {\r\n\t\tvar resolve = state.promise.get(data.code);\r\n\t\tif (resolve) {\r\n\t\t\tstate.promise.delete(data.code);\r\n\t\t\tresolve(data.points);\r\n\t\t} else {\r\n\t\t\tthrow new Error(`no promise code:${data.code}`);\r\n\t\t}\r\n\t}\r\n});"],"sourceRoot":""}