{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","diagram/types.ts","diagram/utils.ts","diagram/Point.ts","diagram/Edge.ts","diagram/Line.ts","diagram/Voronoi.ts","diagram/Triangle.ts","script/VoronoiWorker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","runtime","undefined","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelper","allowArrayLike","it","isArray","minLen","from","test","F","e","_e","f","normalCompletion","didErr","step","_e2","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","_defineProperties","target","props","descriptor","_createClass","Constructor","protoProps","staticProps","_classCallCheck","instance","_setPrototypeOf","_inherits","subClass","superClass","_getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","_typeof","_possibleConstructorReturn","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","Super","NewTarget","Parent","Class","a","_cache","Map","indexOf","has","set","Wrapper","DiagramError","ObjectSet","comparator","hash","collection","compare","map","element","add","tmp","entries","pair","list","every","some","delete","removed","filter","size","clear","consumer","predicate","ZERO","x","y","Number","isFinite","PointInitError","init","digit","isInteger","toFixed","isPoint","equals","p1","p2","hashCode","point","str","charCodeAt","stringHash","isEdge","b","toLine","edge","line","LineInitError","LineError","mes","getIntersection","l1","l2","det","VoronoiError","invert","ERROR","Math","pow","Node","_p1","_p2","index","onBoundary","cnt","isBoundary","previous","hasNext","calcNext","hasPrevious","current","other","forward","node","neighbor","isNeighbor","hasNeighbor","t1","t2","level","onSolved","round","Intersection","intersection","center","_previous","_node","dx","dy","incrementIndex","onIntersectionSolved","release","Bisector","bisector","intersections","delaunayPoint","solvedPointIndexFrom","MAX_SAFE_INTEGER","solvedPointIndexTo","boundary","addIntersection","min","max","addIntersectionAt","insert","splice","indexFrom","indexTo","mid","floor","Voronoi","frame","provider","container","running","targetLevel","time","callback","bisectors","requestedPoint","addedPoint","performance","now","addBoundary","neighbors","addBisector","searchPolygon","loopTime","promise","traverse","all","console","log","nextLevel","tasks","nextUp","hasSolved","history","sample","nextDown","start","requestExtension","task","preexist","triangle","x1","y1","x2","y2","x3","y3","v1","v2","v3","ctx","voronoi","addEventListener","messaage","data","JSON","parse","code","postMessage","stringify","execute","k","polygon","lat","lng","catch","message","points"],"mappings":"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","file":"static/js/VoronoiWorker.dc8a6256.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/ekisagasu/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","\r\nexport interface Point {\r\n\tx: number\r\n\ty: number\r\n}\r\n\r\n\r\nexport interface Line {\r\n\ta: number\r\n\tb: number\r\n\tc: number\r\n}\r\n\r\n\r\nexport interface Edge {\r\n\ta: Point\r\n\tb: Point\r\n}\r\n\r\n\r\nexport interface Triangle {\r\n\ta: Point\r\n\tb: Point\r\n\tc: Point\r\n}\r\n\r\n\r\nexport interface Circle {\r\n\tcenter: Point\r\n\tradius: number\r\n}\r\n\r\nexport interface Rect {\r\n  left: number\r\n  top: number\r\n  right: number\r\n  bottom: number\r\n}\r\n\r\n\r\nexport class DiagramError extends Error {}","\n\nexport function stringHash(str: string): number {\n\t// https://stackoverflow.com/questions/194846/is-there-any-kind-of-hash-code-function-in-javascript\n\t// https://github.com/darkskyapp/string-hash/blob/master/index.js\n\tvar hash = 5381;\n\tif (typeof str === \"string\") {\n\t\tvar i = str.length - 1;\n\t\twhile (i >= 0) {\n\t\t\thash = (hash * 33) ^ str.charCodeAt(i);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn hash & hash;\n}\n\ntype Comparator<E> = (obj1: E, obj2: E) => boolean\ntype HashGetter<E> = (e: E) => number\n\n/**\n * primitiveではないObjectを要素にもつ重複なしの集合を表す\n * 要素の等価判定はコンストラクタに渡されるcomparator（評価器）で定義する\n * hashが計算するハッシュ値は要素の検索高速化のために使うが、\n * comparator(obj1,obj2) === true ならば hash(obj1) === hash(obj2) でなければならない\n * 演算子\"===\"でハッシュ値の等価性を評価するとおり、ハッシュ値はprimitiveでなければならない\n * 検索の高速化のためには、\n * hash(obj1) === hash(obj2) かつ comparator(obj1,obj2) === false となるハッシュの衝突はできるだけ避けるのが望ましい\n */\nexport class ObjectSet<E> {\n\n\t/**\n\t * \n\t * @param {(obj1,obj2) => boolean} comparator 要素の等価判定を行う\n\t * @param {(obj) => hashCode} hash 要素のハッシュ値を計算する\n\t * @param {iterable} collection 初期化する要素（省略可）\n\t */\n\tconstructor(comparator: Comparator<E>, hash: HashGetter<E>, collection?: Array<E>) {\n\t\tthis.compare = comparator;\n\t\tthis.hash = hash;\n\t\tthis.map = new Map();\n\t\tif (collection) {\n\t\t\tcollection.forEach(element => {\n\t\t\t\tthis.add(element);\n\t\t\t});\n\t\t}\n\t}\n\n\tcompare: Comparator<E>\n\thash: HashGetter<E>\n\tmap: Map<number, Array<E>>\n\n\tclone() {\n\t\tvar tmp = new ObjectSet<E>(this.compare, this.hash);\n\t\tfor (let pair of this.map.entries()) {\n\t\t\tvar key: number = pair[0];\n\t\t\tvar list = pair[1];\n\t\t\ttmp.map.set(key, Array.from(list));\n\t\t}\n\t\treturn tmp;\n\t}\n\n\t/**\n\t * 要素の追加を行う\n\t * @param {*} e 追加したい要素\n\t * @return {boolean} 既存の集合に等価な要素が存在せず追加に成功したらtrue, false otherwise\n\t */\n\tadd(e: E): boolean {\n\t\tvar hash = this.hash(e);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.every(element => !this.compare(element, e))) {\n\t\t\t\tlist.push(e);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else {\n\t\t\tlist = [e];\n\t\t\tthis.map.set(hash, list);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * 指定した要素が集合に含まれるか判定する\n\t * @param {*} e 検査対象の要素\n\t */\n\thas(e: E): boolean {\n\t\tvar list = this.map.get(this.hash(e));\n\t\treturn !!list && list.some(element => this.compare(element, e));\n\t}\n\n\t/**\n\t * 指定した要素の削除を行う\n\t * @param {*} e 削除したい要素\n\t * @return {boolean} 集合に削除対象の要素が存在し削除に成功したらtrue, false otherwise\n\t */\n\tremove(e: E): boolean {\n\t\tvar hash = this.hash(e);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.length === 1 && this.compare(list[0], e)) {\n\t\t\t\tthis.map.delete(hash);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar removed = list.filter(element => !this.compare(element, e));\n\t\t\tif (list.length === removed.length) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis.map.set(hash, removed);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tsize(): number {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tsize += list.length;\n\t\t}\n\t\treturn size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => void} consumer \n\t */\n\tforEach(consumer: (e: E) => void): void {\n\t\tfor (let value of this) {\n\t\t\tconsumer(value);\n\t\t}\n\t}\n\n\t*[Symbol.iterator]() {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let value of list) {\n\t\t\t\tsize += 1;\n\t\t\t\tyield value;\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => boolean} predicate \n\t */\n\tfilter(predicate: (e: E) => boolean): ObjectSet<E> {\n\t\tvar tmp = new ObjectSet(this.compare, this.hash);\n\t\tfor (let element of this) {\n\t\t\tif (predicate(element)) tmp.add(element);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\t/**\n\t * \n\t * @param {(obj) => boolean} predicate \n\t */\n\tremoveIf(predicate: (e: E) => boolean): ObjectSet<E> {\n\t\tvar tmp = new ObjectSet(this.compare, this.hash);\n\t\tfor (let element of this) {\n\t\t\tif (!predicate(element)) tmp.add(element);\n\t\t}\n\t\treturn tmp;\n\t}\n}\n\ntype MapEntry<K, V> = {\n\tkey: K,\n\tvalue: V | null\n}\n\nexport class ObjectMap<K, V> {\n\n\tconstructor(comparator: Comparator<K>, hash: HashGetter<K>) {\n\t\tthis.compare = comparator;\n\t\tthis.hash = hash;\n\t\tthis.map = new Map();\n\t}\n\n\tcompare: Comparator<K>\n\thash: HashGetter<K>\n\tmap: Map<number, Array<MapEntry<K, V>>>\n\n\tput(key: K, value: V | null): void {\n\t\tvar hash = this.hash(key);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\t\tif (index < 0) {\n\t\t\t\tvar pair: MapEntry<K, V> = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value\n\t\t\t\t}\n\t\t\t\tlist.push(pair);\n\t\t\t} else {\n\t\t\t\tlist[index].value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tlist = [\n\t\t\t\t{\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value\n\t\t\t\t}\n\t\t\t];\n\t\t\tthis.map.set(hash, list);\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\tvar list = this.map.get(this.hash(key));\n\t\treturn !!list && list.some(pair => this.compare(pair.key, key));\n\t}\n\n\tget(key: K, defaultValue?: V | null): V | null {\n\t\tvar list = this.map.get(this.hash(key));\n\t\tif (!list) return null;\n\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\tif (index < 0) {\n\t\t\tif ( defaultValue ) return defaultValue\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn list[index].value;\n\t\t}\n\t}\n\n\tgetValue(key: K): V {\n\t\tvar value = this.get(key)\n\t\tif ( value ) return value\n\t\tthrow new Error(`no such element. key:${key}`)\n\t}\n\n\t/**\n\t * 指定されたkeyにマッピングされたvalueを削除する\n\t * @param {*} key \n\t * @return {obj} 削除されたvalue, 削除に失敗した場合はnull\n\t */\n\tremove(key: K): V | null {\n\t\tvar hash = this.hash(key);\n\t\tvar list = this.map.get(hash);\n\t\tif (list) {\n\t\t\tif (list.length === 1 && this.compare(list[0].key, key)) {\n\t\t\t\tthis.map.delete(hash);\n\t\t\t\treturn list[0].value;\n\t\t\t}\n\t\t\tvar index = list.findIndex(pair => this.compare(pair.key, key));\n\t\t\tif (index < 0) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tvar value = list[index].value;\n\t\t\t\tvar removed = list.filter(pair => !this.compare(pair.key, key));\n\t\t\t\tthis.map.set(hash, removed);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tsize(): number {\n\t\tvar size = 0;\n\t\tfor (let list of this.map.values()) {\n\t\t\tsize += list.length;\n\t\t}\n\t\treturn size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\t/**\n\t * \n\t * @param {(key) => void} consumer \n\t */\n\tforEachKey(consumer: (key: K) => void) {\n\t\tfor (let key of this.keys()) {\n\t\t\tconsumer(key);\n\t\t}\n\t}\n\n\t* keys() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tyield entry.key;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {(value) => void} consumer \n\t */\n\tforEachValue(consumer: (value: V | null) => void) {\n\t\tfor (let value of this.values()) {\n\t\t\tconsumer(value);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tyield entry.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {(entry: {key:any, value:any}) => void} consumer \n\t */\n\tforEachEntries(consumer: (e: MapEntry<K, V>) => void) {\n\t\tfor (let entry of this.entries()) {\n\t\t\tconsumer(entry);\n\t\t}\n\t}\n\n\t* entries() {\n\t\tfor (let list of this.map.values()) {\n\t\t\tfor (let entry of list) {\n\t\t\t\tvar tmp = {\n\t\t\t\t\tkey: entry.key,\n\t\t\t\t\tvalue: entry.value\n\t\t\t\t};\n\t\t\t\tyield tmp;\n\t\t\t}\n\t\t}\n\t}\n\n}","import { stringHash } from \"./utils\"\nimport {Point, DiagramError} from \"./types\"\n\nexport const ZERO: Point = init(0, 0)\n\nclass PointInitError extends DiagramError {\n\tconstructor(x: number, y: number) {\n\t\tsuper(`cannot get an instance with x:${x} y:${y}`)\n\t}\n}\n\nexport function toString(p: Point, digit?: number) {\n\tif (digit && Number.isInteger(digit) && digit > 0) {\n\t\treturn `(${p.x.toFixed(digit)},${p.y.toFixed(digit)})`\n\t}\n\treturn `(${p.x},${p.y})`\n}\n\nexport function isPoint(p: any): p is Point {\n\treturn p !== null && typeof p === \"object\" && typeof p.x === \"number\" && typeof p.y === \"number\"\n}\n\nexport function init(x: number, y: number): Point {\n\tif (Number.isFinite(x) && Number.isFinite(y)) {\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t}\n\t}\n\tthrow new PointInitError(x, y)\n}\n\nexport function equals(p1: Point, p2: Point): boolean {\n\treturn p1.x === p2.x && p1.y === p2.y\n}\n\nexport function hashCode(point: Point): number {\n\tvar str = `${point.x.toString()},${point.y.toString}`\n\treturn stringHash(str)\n}\n\nexport function getDivision(p1: Point, p2: Point, index: number): Point {\n\treturn {\n\t\tx: p1.x * (1.0 - index) + p2.x * index,\n\t\ty: p1.y * (1.0 - index) + p2.y * index,\n\t}\n}\n\nexport function measure(p1: Point, p2: Point): number {\n\treturn Math.sqrt(\n\t\tMath.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)\n\t)\n}\n\nexport function getMiddlePoint(p1: Point, p2: Point): Point {\n\treturn {\n\t\tx: (p1.x + p2.x) / 2,\n\t\ty: (p1.y + p2.y) / 2,\n\t}\n}\n\nexport function compare(p1: Point, p2: Point): number {\n\tif (p1.x === p2.x) {\n\t\tif (p1.y === p2.y) {\n\t\t\treturn 0\n\t\t} else if (p1.y < p2.y) {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 1\n\t\t}\n\t} else if (p1.x < p2.x) {\n\t\treturn -1\n\t} else {\n\t\treturn 1\n\t}\n}","import * as line from \"./Line\";\nimport * as point from \"./Point\";\nimport {Point, Line, Edge, DiagramError} from \"./types\"\n\nexport function toString(e: Edge) {\n\treturn `{${point.toString(e.a)}-${point.toString(e.b)}}`\n}\n\nexport function isEdge(p: any): p is Edge {\n\treturn p !== null &&\n\t\ttypeof p === \"object\" &&\n\t\tpoint.isPoint(p.a) &&\n\t\tpoint.isPoint(p.b)\n\n}\n\nclass EdgeError extends DiagramError {}\n\nclass EdgeInitError extends DiagramError {\n\tconstructor(p: Point) {\n\t\tsuper(`point duplicated: ${point.toString(p)}`)\n\t}\n}\n\nexport function init(a: Point, b: Point): Edge {\n\tif (a.x < b.x) {\n\t\treturn { a: a, b: b };\n\t} else if (a.x > b.x) {\n\t\treturn { a: b, b: a };\n\t} else {\n\t\tif (a.y < b.y) {\n\t\t\treturn { a: a, b: b };\n\t\t} else if (a.y > b.y) {\n\t\t\treturn { a: b, b: a };\n\t\t} else {\n\t\t\tthrow new EdgeInitError(a)\n\t\t}\n\t}\n}\n\nexport function toLine(edge: Edge): Line {\n\treturn line.init(edge.a, edge.b);\n}\n\nexport function equals(self: Edge, other: Edge): boolean {\n\treturn point.equals(self.a, other.a) && point.equals(self.b, other.b);\n}\n\nexport function hashCode(edge: Edge): number {\n\tvar hash = 17;\n\thash = 31 * hash + point.hashCode(edge.a);\n\thash = 31 * hash + point.hashCode(edge.b);\n\treturn hash & hash;\n}\n\nexport function getMiddlepoint(edge: Edge): Point {\n\treturn {\n\t\tx: (edge.a.x + edge.b.x) / 2,\n\t\ty: (edge.a.y + edge.b.y) / 2,\n\t};\n}\n\nexport function onEdge(p1: Edge | Point, p2: Point, p3?: Point): boolean {\n\tif (isEdge(p1)) {\n\t\tp3 = p2\n\t\tvar edge = p1\n\t\tp1 = edge.a\n\t\tp2 = edge.b\n\t}\n\tif (p3) {\n\t\tvar start: Point = p1\n\t\tvar end: Point = p2\n\t\tvar p: Point = p3\n\t\tif ((start.x - p.x) * (end.x - p.x) + (start.y - p.y) * (end.y - p.y) <= 0) {\n\t\t\treturn line.onLine(start, end, p);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tthrow new EdgeError(\"invalid arguments\")\n}\n\nexport function getDivision(edge: Edge, index: number): Point {\n\treturn point.getDivision(edge.a, edge.b, index);\n}\n\n/**\n * 交点を取得する\n * @param {edge} edge \n * @param {edge/line} other \n * @return null if no such point\n */\nexport function getIntersection(edge: Edge, other: Edge | Line): Point | null {\n\tif (line.isLine(other)) {\n\t\tvar p = line.getIntersection(toLine(edge), other);\n\t\tif (p) {\n\t\t\tvar v = (edge.a.x - p.x) * (edge.b.x - p.x) + (edge.a.y - p.y) * (edge.b.y - p.y);\n\t\t\treturn v <= 0 ? p : null;\n\t\t}\n\t\treturn null\n\t} else {\n\t\tp = getIntersection(edge, toLine(other));\n\t\tif (p) {\n\t\t\tv = (other.a.x - p.x) * (other.b.x - p.x) + (other.a.y - p.y) * (other.b.y - p.y);\n\t\t\tif (v <= 0) return p;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport function getDistance(edge: Edge, p: Point): number {\n\tvar v1 = (p.x - edge.a.x) * (edge.b.x - edge.a.x) + (p.y - edge.a.y) * (edge.b.y - edge.a.y);\n\tvar v2 = (p.x - edge.b.x) * (edge.a.x - edge.b.x) + (p.y - edge.b.y) * (edge.a.y - edge.b.y);\n\tif (v1 > 0 && v2 > 0) {\n\t\treturn line.getDistance(toLine(edge), p);\n\t} else if (v1 <= 0) {\n\t\treturn point.measure(edge.a, p);\n\t} else {\n\t\treturn point.measure(edge.b, p);\n\t}\n}","import * as point from \"./Point\"\nimport * as edge from \"./Edge\"\nimport {Point, Line, Edge, DiagramError} from \"./types\"\n\nclass LineInitError extends DiagramError {}\n\nclass LineError extends DiagramError {\n\tconstructor(mes: string, line?: Line) {\n\t\tsuper(line ? `${mes} line:${toString(line)}` : mes)\n\t}\n}\n\nexport function toString(line: Line): string {\n\treturn `{ax+by+c=0 with a:${line.a},b:${line.b},c:${line.c}}`\n}\n\nexport function isLine(p: any): p is Line {\n\treturn p !== null &&\n\t\ttypeof p === \"object\" &&\n\t\ttypeof p.a === \"number\" &&\n\t\ttypeof p.b === \"number\" &&\n\t\ttypeof p.c === \"number\"\n}\n\n/**\n * Gets an instance of a new line. Pairs of argments are; \n * (1) a, b, c: number => a line defined by equation: ax + by + c = 0\n * (2) a, b: Point => a line which goes through the both points\n * @param a \n * @param b \n * @param c \n */\nexport function init(a: number | Point, b: number | Point, c?: number): Line {\n\tif (typeof a === \"number\" && typeof b === \"number\") {\n\t\tif (typeof c === \"number\") {\n\t\t\tif (b === 0) {\n\t\t\t\tif (a === 0) {\n\t\t\t\t\tthrow new LineInitError(\"a = b = 0\")\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ta: 1.0,\n\t\t\t\t\tb: 0.0,\n\t\t\t\t\tc: c / a,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ta: a / b,\n\t\t\t\t\tb: 1.0,\n\t\t\t\t\tc: c / b,\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: -a,\n\t\t\t\tb: 1.0,\n\t\t\t\tc: -b,\n\t\t\t};\n\t\t}\n\t} else if (point.isPoint(a) && point.isPoint(b)) {\n\t\tif (point.equals(a, b)) {\n\t\t\tthrow new LineInitError(`duplicated point: ${point.toString(a)}`)\n\t\t} else if (a.x === b.x) {\n\t\t\treturn {\n\t\t\t\ta: 1.0,\n\t\t\t\tb: 0.0,\n\t\t\t\tc: -(a.x + b.x) / 2,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: (b.y - a.y) / (a.x - b.x),\n\t\t\t\tb: 1.0,\n\t\t\t\tc: (b.x * a.y - a.x * b.y) / (a.x - b.x),\n\t\t\t};\n\t\t}\n\t}\n\tthrow new LineInitError(`cannot get an instance with a:${a} b:${b} c:${c}`)\n}\n\n/**\n * Check if a point is located on the given line. \n * (1) a: Line, b: Point => whether point 'b' is located on line 'a' \n * (2) a: Point, b :Point, c: Point => whether point 'c' is located on a line connecting two points 'a' and 'b'\n * @param {line/point} a \n * @param {point} b \n * @param {point} c \n */\nexport function onLine(a: Line | Point, b: Point, c?: Point): boolean {\n\tif (isLine(a) && point.isPoint(b)) {\n\t\tvar line = a;\n\t\tvar p = b;\n\t\treturn Math.abs(line.a * p.x + line.b * p.y + line.c) === 0;\n\t}\n\tif (point.isPoint(a) && point.isPoint(b) && point.isPoint(c)) {\n\t\tvar v = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\t\treturn v === 0;\n\t}\n\tthrow new LineError(\"invalid arguments\")\n}\n\nexport function equals(l1: Line, l2: Line): boolean {\n\treturn l1.a === l2.a && l1.b === l2.b && l1.c === l2.c;\n}\n\nexport function getIntersection(l1: Line, l2: Line | Edge): Point | null {\n\tif (edge.isEdge(l2)) {\n\t\t// l1:Line l2:edge\n\t\tvar line = l1;\n\t\tvar e = l2;\n\t\tif ((line.a * e.a.x + line.b * e.a.y + line.c) * (line.a * e.b.x + line.b * e.b.y + line.c) <= 0) {\n\t\t\tl2 = edge.toLine(e);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\t// l1:Line l2:Line\n\tvar det = l1.a * l2.b - l2.a * l1.b;\n\tif (det === 0) {\n\t\treturn null;\n\t} else {\n\t\treturn {\n\t\t\tx: (l1.b * l2.c - l2.b * l1.c) / det,\n\t\t\ty: (l2.a * l1.c - l1.a * l2.c) / det,\n\t\t};\n\t}\n}\n\nexport function getPerpendicularBisector(p1: Point | Edge, p2?: Point): Line {\n\tif (edge.isEdge(p1)) {\n\t\t// p1:edge p2:null\n\t\tvar e = p1;\n\t\tp1 = e.a;\n\t\tp2 = e.b;\n\t}\n\tif (p2) {\n\n\t\t// p1,p2:Point\n\t\treturn {\n\t\t\ta: p1.x - p2.x,\n\t\t\tb: p1.y - p2.y,\n\t\t\tc: (-Math.pow(p1.x, 2) - Math.pow(p1.y, 2) + Math.pow(p2.x, 2) + Math.pow(p2.y, 2)) / 2,\n\t\t}\n\t}\n\tthrow new LineError(`invalid arguments p1:${p1},p2:${p2}`)\n}\n\nexport function getDistance(line: Line, point: Point): number {\n\treturn Math.abs(point.x * line.a + point.y * line.b + line.c) / Math.sqrt(line.a * line.a + line.b * line.b);\n}\n\nexport function onSameSide(line: Line, p1: Point, p2: Point): boolean {\n\tvar v1 = line.a * p1.x + line.b * p1.y + line.c;\n\tvar v2 = line.a * p2.x + line.b * p2.y + line.c;\n\treturn v1 * v2 >= 0;\n}\n","import { Point, Line, Edge, Triangle, DiagramError } from \"./types\"\r\nimport * as point from \"./Point\";\r\nimport * as line from \"./Line\";\r\nimport * as triangle from \"./Triangle\";\r\nimport { ObjectSet } from \"./utils\";\r\n\r\nclass VoronoiError extends DiagramError {\r\n\tconstructor(mes: string) {\r\n\t\tsuper(mes)\r\n\t}\r\n}\r\n\r\n/**\r\n * 二等分線の交点の前後における次数の変化量\r\n */\r\ntype StepDirection = \"up\" | \"zero\" | \"down\"\r\n\r\nfunction invert(step: StepDirection): StepDirection {\r\n\tswitch (step) {\r\n\t\tcase \"up\":\r\n\t\t\treturn \"down\"\r\n\t\tcase \"down\":\r\n\t\t\treturn \"up\"\r\n\t\tcase \"zero\":\r\n\t\t\treturn \"zero\"\r\n\t}\r\n}\r\n\r\nconst ERROR = Math.pow(2, -30);\r\n\r\n/**\r\n * Point + 付加情報 のラッパー  \r\n * 二つの二等分線の交点においてBisectorオブジェクトどうしの接続をモデル化\r\n */\r\nclass Node implements Point {\r\n\r\n\tconstructor(p: Point, a: Intersection, b: Intersection) {\r\n\t\tthis.x = p.x;\r\n\t\tthis.y = p.y;\r\n\t\tthis._p1 = a;\r\n\t\tthis._p2 = b;\r\n\t\tvar cnt = 0;\r\n\t\tif (a.line.isBoundary) cnt++;\r\n\t\tif (b.line.isBoundary) cnt++;\r\n\t\tif (cnt === 0) {\r\n\t\t\tthis.onBoundary = false;\r\n\t\t\tthis.index = -1;\r\n\t\t} else if (cnt === 1) {\r\n\t\t\tthis.onBoundary = true;\r\n\t\t\tthis.index = -1;\r\n\t\t} else {\r\n\t\t\tthis.onBoundary = false;\r\n\t\t\tthis.index = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tx: number\r\n\ty: number\r\n\r\n\t// 各二等分線上の交点\r\n\t_p1: Intersection | null\r\n\t_p2: Intersection | null\r\n\r\n\tget p1(): Intersection {\r\n\t\tif (this._p1) return this._p1\r\n\t\tthrow new VoronoiError(\"no intersection\")\r\n\t}\r\n\r\n\r\n\tget p2(): Intersection {\r\n\t\tif (this._p2) return this._p2\r\n\t\tthrow new VoronoiError(\"no intersection\")\r\n\t}\r\n\r\n\tindex: number\r\n\tonBoundary: boolean\r\n\r\n\t/**\r\n\t * 辿ってきた辺とは異なる線分上の隣接頂点でかつ辺のボロノイ次数が同じになる方を返す.\r\n\t * @param previous from which you are traversing\r\n\t * @return Node\r\n\t */\r\n\tnext(previous: Point) {\r\n\t\tconst p1 = this.p1;\r\n\t\tconst p2 = this.p2;\r\n\t\tif (p1.hasNext && point.equals(p1.next, previous)) {\r\n\t\t\treturn this.calcNext(p1, p2, false, invert(p1.step));\r\n\t\t} else if (p1.hasPrevious && point.equals(p1.previous, previous)) {\r\n\t\t\treturn this.calcNext(p1, p2, true, p1.step);\r\n\t\t} else if (p2.hasNext && point.equals(p2.next, previous)) {\r\n\t\t\treturn this.calcNext(p2, p1, false, invert(p2.step));\r\n\t\t} else if (p2.hasPrevious && point.equals(p2.previous, previous)) {\r\n\t\t\treturn this.calcNext(p2, p1, true, p2.step);\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"next node not found.\");\r\n\t\t}\r\n\t}\r\n\r\n\tcalcNext(current: Intersection, other: Intersection, forward: boolean, step: StepDirection) {\r\n\t\tif (this.onBoundary && this.index > 0) {\r\n\t\t\t// 頂点がFrame境界線上（Vertexではない）でかつ\r\n\t\t\t// この頂点が解決済みなら無視して同じ境界線上のお隣さんへ辿る\r\n\t\t\treturn forward ? current.next.node : current.previous.node;\r\n\t\t} else {\r\n\t\t\t// 頂点がFrame内部なら step = Node.STEP_UP/DOWN　のいずれか\r\n\t\t\t// FrameのVertexに位置する場合は例外的に step = Node.STEP_ZERO\r\n\t\t\treturn other.neighbor(invert(step)).node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 辿ってきた辺とは異なる線分上の隣接頂点のうちこの頂点から見てボロノイ次数が\r\n\t\t\t\t * 下がるまたは変化しない方を返す.<br>\r\n\t\t\t\t * この頂点がFrame内部なら必ず次数が下がる隣接頂点を返すが、\r\n\t\t\t\t * Frame境界線のVertexに相当する場合は例外的に次数変化0の方向の頂点を返す\r\n\t * @param previous \r\n\t */\r\n\tnextDown(previous: Point): Node {\r\n\t\tvar target: any = null;\r\n\t\tif (this.p1.isNeighbor(previous)) {\r\n\t\t\ttarget = this.p2;\r\n\t\t} else if (this.p2.isNeighbor(previous)) {\r\n\t\t\ttarget = this.p1;\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"neighbor not found\");\r\n\t\t}\r\n\t\tif (target.hasNeighbor(\"down\")) {\r\n\t\t\treturn target.neighbor(\"down\").node;\r\n\t\t} else {\r\n\t\t\treturn target.neighbor(\"zero\").node;\r\n\t\t}\r\n\t}\r\n\r\n\tnextUp(previous: Point): Node | null {\r\n\t\tvar t1: any = null;\r\n\t\tvar t2: any = null;\r\n\t\tif (this.p1.isNeighbor(previous)) {\r\n\t\t\tt1 = this.p2;\r\n\t\t\tt2 = this.p1;\r\n\t\t} else if (this.p2.isNeighbor(previous)) {\r\n\t\t\tt1 = this.p1;\r\n\t\t\tt2 = this.p2;\r\n\t\t} else {\r\n\t\t\tthrow new VoronoiError(\"neighbor not found\");\r\n\t\t}\r\n\t\tif (t1.hasNeighbor(\"up\")) {\r\n\t\t\treturn t1.neighbor(\"up\").node;\r\n\t\t} else if (t2.hasNeighbor(\"up\")) {\r\n\t\t\treturn t2.neighbor(\"up\").node;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tonSolved(level: number): void {\r\n\t\tthis.p1.onSolved();\r\n\t\tthis.p2.onSolved();\r\n\t\tif (this.index < 0) {\r\n\t\t\tif (this.p1.line.isBoundary || this.p2.line.isBoundary) {\r\n\t\t\t\tthis.index = level;\r\n\t\t\t} else {\r\n\t\t\t\tthis.index = level + 0.5;\r\n\t\t\t}\r\n\t\t} else if (Math.round(this.index) !== this.index) {\r\n\t\t\tif (this.index + 0.5 !== level) throw new VoronoiError(\"index mismatch\");\r\n\t\t}\r\n\t}\r\n\r\n\thasSolved(): boolean {\r\n\t\treturn this.index >= 0;\r\n\t}\r\n\r\n\trelease() {\r\n\t\tthis._p1 = null;\r\n\t\tthis._p2 = null;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * 各二等分線上において他の線分との交点をモデル化\r\n * 交点によって分割され線分の次数変化を調べる\r\n */\r\nclass Intersection implements Point {\r\n\r\n\tconstructor(intersection: Point, b: Bisector, other?: Line, center?: Point) {\r\n\t\tthis.line = b;\r\n\t\tthis.x = intersection.x;\r\n\t\tthis.y = intersection.y;\r\n\r\n\t\tif (other && center) {\r\n\r\n\t\t\tvar dx = b.line.b;\r\n\t\t\tvar dy = -b.line.a;\r\n\t\t\tif (dx < 0 || (dx === 0 && dy < 0)) {\r\n\t\t\t\tdx *= -1;\r\n\t\t\t\tdy *= -1;\r\n\t\t\t}\r\n\t\t\tvar p = {\r\n\t\t\t\tx: intersection.x + dx,\r\n\t\t\t\ty: intersection.y + dy\r\n\t\t\t};\r\n\t\t\tthis.step = line.onSameSide(other, p, center) ? \"down\" : \"up\";\r\n\t\t} else {\r\n\t\t\tthis.step = \"zero\";\r\n\t\t}\r\n\t}\r\n\r\n\tx: number\r\n\ty: number\r\n\tline: Bisector\r\n\tstep: StepDirection\r\n\r\n\t_previous: Intersection | null | undefined = undefined\r\n\t_next: Intersection | null | undefined = undefined\r\n\tindex: number = 0\r\n\r\n\t_node: Node | null = null\r\n\r\n\tget hasPrevious(): boolean {\r\n\t\tif (this._previous === undefined) {\r\n\t\t\tthrow new VoronoiError(\"previous not init yet\")\r\n\t\t}\r\n\t\treturn this._previous !== null\r\n\t}\r\n\r\n\tget previous(): Intersection {\r\n\t\tif (this._previous) return this._previous\r\n\t\tif (this._previous === undefined) {\r\n\t\t\tthrow new VoronoiError(\"previous not init yet\")\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"no previous\")\r\n\t}\r\n\r\n\tget hasNext(): boolean {\r\n\t\tif (this._next === undefined) {\r\n\t\t\tthrow new VoronoiError(\"next not init yet\")\r\n\t\t}\r\n\t\treturn this._next !== null\r\n\t}\r\n\r\n\tget next(): Intersection {\r\n\t\tif (this._next) return this._next\r\n\t\tif (this._next === undefined) {\r\n\t\t\tthrow new VoronoiError(\"next not init yet\")\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"no next\")\r\n\t}\r\n\r\n\tget node(): Node {\r\n\t\tif (this._node) return this._node\r\n\t\tthrow new VoronoiError(\"no node\")\r\n\t}\r\n\r\n\tset node(value: Node) {\r\n\t\tif (this._node) throw new VoronoiError(\"node already set\")\r\n\t\tthis._node = value\r\n\t}\r\n\r\n\tinsert(previous: Intersection | null, next: Intersection | null, index: number): void {\r\n\t\tthis._previous = previous;\r\n\t\tthis._next = next;\r\n\t\tif (this._previous) {\r\n\t\t\tthis._previous._next = this;\r\n\t\t}\r\n\t\tif (this._next) {\r\n\t\t\tthis._next._previous = this;\r\n\t\t\tthis._next.incrementIndex();\r\n\t\t}\r\n\t\tthis.index = index;\r\n\t}\r\n\r\n\tincrementIndex(): void {\r\n\t\tthis.index++;\r\n\t\tif (this._next) this._next.incrementIndex();\r\n\t}\r\n\r\n\tisNeighbor(p: Point): boolean {\r\n\t\treturn (this.hasNext && point.equals(this.next, p))\r\n\t\t\t|| (this.hasPrevious && point.equals(this.previous, p));\r\n\t}\r\n\r\n\thasNeighbor(step: StepDirection): boolean {\r\n\t\tif (step === \"zero\" && this.step === \"zero\") {\r\n\t\t\treturn true;\r\n\t\t} else if (step !== \"zero\" && this.step !== \"zero\") {\r\n\t\t\treturn (step === this.step) ? !!this._next : !!this._previous;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tneighbor(step: StepDirection): Intersection {\r\n\t\tif (step === \"zero\" && this.step === \"zero\") {\r\n\t\t\tif (this._previous) return this._previous;\r\n\t\t\tif (this._next) return this._next;\r\n\t\t} else if (step !== \"zero\" && this.step !== \"zero\") {\r\n\t\t\treturn (step === this.step) ? this.next : this.previous;\r\n\t\t}\r\n\t\tthrow new VoronoiError(\"neighbor step invalid.\");\r\n\t}\r\n\r\n\tonSolved(): void {\r\n\t\tthis.line.onIntersectionSolved(this);\r\n\t}\r\n\r\n\trelease(): void {\r\n\t\tthis._previous = null;\r\n\t\tthis._next = null;\r\n\t\tif (this._node) {\r\n\t\t\tthis._node.release();\r\n\t\t\tthis._node = null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * ボロノイ分割を構成する二等分線を表現\r\n */\r\nclass Bisector {\r\n\r\n\tconstructor(bisector: Line, p?: Point) {\r\n\t\tthis.line = bisector;\r\n\t\tthis.intersections = [];\r\n\t\tif (p) {\r\n\t\t\tthis.delaunayPoint = p;\r\n\t\t\tthis.isBoundary = false;\r\n\t\t} else {\r\n\t\t\tthis.delaunayPoint = null;\r\n\t\t\tthis.isBoundary = true;\r\n\t\t}\r\n\t}\r\n\r\n\tline: Line\r\n\tintersections: Array<Intersection>\r\n\tisBoundary: boolean\r\n\tdelaunayPoint: Point | null\r\n\r\n\tsolvedPointIndexFrom: number = Number.MAX_SAFE_INTEGER\r\n\tsolvedPointIndexTo: number = -1\r\n\r\n\t/**\r\n\t * \r\n\t * @param boundary\r\n\t */\r\n\tinspectBoundary(boundary: Edge): void {\r\n\t\tvar p = line.getIntersection(this.line, boundary);\r\n\t\tif (p) {\r\n\t\t\tvar i = new Intersection(p, this)\r\n\t\t\tthis.addIntersection(i);\r\n\t\t}\r\n\t}\r\n\r\n\tonIntersectionSolved(intersection: Intersection): void {\r\n\t\tvar index = intersection.index;\r\n\t\tthis.solvedPointIndexFrom = Math.min(\r\n\t\t\tthis.solvedPointIndexFrom,\r\n\t\t\tindex\r\n\t\t);\r\n\t\tthis.solvedPointIndexTo = Math.max(\r\n\t\t\tthis.solvedPointIndexTo,\r\n\t\t\tindex\r\n\t\t);\r\n\t}\r\n\r\n\taddIntersection(intersection: Intersection): void {\r\n\t\tconst size = this.intersections.length;\r\n\t\tvar index = this.addIntersectionAt(intersection, 0, size);\r\n\t\tintersection.insert(\r\n\t\t\tindex > 0 ? this.intersections[index - 1] : null,\r\n\t\t\tindex < size ? this.intersections[index] : null,\r\n\t\t\tindex\r\n\t\t);\r\n\t\tthis.intersections.splice(index, 0, intersection);\r\n\t\tif (this.solvedPointIndexFrom < this.solvedPointIndexTo) {\r\n\t\t\tif (index <= this.solvedPointIndexFrom) {\r\n\t\t\t\tthis.solvedPointIndexFrom++;\r\n\t\t\t\tthis.solvedPointIndexTo++;\r\n\t\t\t} else if (index <= this.solvedPointIndexTo) {\r\n\t\t\t\tthrow new VoronoiError(\"new intersection added to solved range.\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddIntersectionAt(p: Point, indexFrom: number, indexTo: number): number {\r\n\t\tif (indexFrom === indexTo) {\r\n\t\t\treturn indexFrom;\r\n\t\t} else {\r\n\t\t\tvar mid = Math.floor((indexFrom + indexTo - 1) / 2);\r\n\t\t\tvar r = point.compare(p, this.intersections[mid]);\r\n\t\t\tif (r < 0) {\r\n\t\t\t\treturn this.addIntersectionAt(p, indexFrom, mid);\r\n\t\t\t} else if (r > 0) {\r\n\t\t\t\treturn this.addIntersectionAt(p, mid + 1, indexTo);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VoronoiError(\"same point already added in this bisector\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trelease(): void {\r\n\t\tthis.intersections.forEach(i => i.release());\r\n\t\tthis.intersections.splice(0, this.intersections.length)\r\n\t}\r\n\r\n}\r\n\r\n/** \r\n * 母点集合において指定された点の隣接点を取得する\r\n */\r\nexport type PointProvider = (p: Point) => Promise<Array<Point>>\r\n\r\n/**\r\n * 各次数における計算結果のコールバック関数\r\n * @param index 次数（１始まりで数えた数字）\r\n * @param polygon ポリゴンを成す座標点を順にもつリスト\r\n */\r\nexport type Callback = (index: number, polygon: Array<Point>) => void\r\n\r\n/**\r\n * 高次ボロノイ分割を計算する\r\n */\r\nexport class Voronoi {\r\n\r\n\t/**\r\n\t * \r\n\t * @param {triangle} frame \r\n\t * @param {(point)=>Promise<array>} provider \r\n\t */\r\n\tconstructor(frame: Triangle, provider: PointProvider) {\r\n\t\tthis.container = frame;\r\n\t\tthis.provider = provider;\r\n\t}\r\n\r\n\tcontainer: Triangle\r\n\tprovider: PointProvider\r\n\trunning: boolean = false\r\n\r\n\t/**\r\n\t * 高次ボロノイ分割を計算する\r\n\t * \r\n\t * １次から指定された次数まで逐次的に計算する\r\n\t * @param {number} level 計算する次数\r\n\t * @param {point} center 中心点\r\n\t * @param {(index: number,polygon: array)=>void} callback 各次数でのボロノイ領域（ポリゴン）が計算されるたびにコールバックする\r\n\t * @return 1..indexまでの次数の順に計算されたポリゴンを格納したリストのPromise\r\n\t */\r\n\tasync execute(level: number, center: Point, callback: Callback | null): Promise<Array<Array<Point>>> {\r\n\t\tif (this.running) return Promise.reject(\"already running\");\r\n\t\tthis.running = true;\r\n\r\n\t\ttry {\r\n\r\n\t\t\tthis.center = center;\r\n\t\t\tthis.level = level;\r\n\t\t\tthis.targetLevel = 1;\r\n\t\t\tthis.list = null;\r\n\t\t\tthis.time = performance.now();\r\n\t\t\tthis.result = [];\r\n\t\t\tthis.callback = callback;\r\n\t\t\tthis.bisectors = [];\r\n\t\t\tthis.addBoundary(line.init(this.container.a, this.container.b));\r\n\t\t\tthis.addBoundary(line.init(this.container.b, this.container.c));\r\n\t\t\tthis.addBoundary(line.init(this.container.c, this.container.a));\r\n\t\t\tthis.requestedPoint = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tthis.addedPoint = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tthis.requestedPoint.add(center);\r\n\t\t\tthis.addedPoint.add(center);\r\n\t\t\tconst neighbors = await this.provider(center);\r\n\t\t\tfor (let p of neighbors) {\r\n\t\t\t\tif (this.addedPoint.add(p))\r\n\t\t\t\t\tthis.addBisector(p);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn Promise.reject(e)\r\n\t\t}\r\n\t\treturn this.searchPolygon();\r\n\r\n\t}\r\n\r\n\tcenter: Point = point.ZERO\r\n\tlevel: number = 0\r\n\ttargetLevel: number = 1\r\n\tlist: Array<Node> | null = null\r\n\ttime: number = 0\r\n\tresult: Array<Array<Point>> = []\r\n\tcallback: Callback | null = null\r\n\tbisectors: Array<Bisector> = []\r\n\r\n\r\n\trequestedPoint: ObjectSet<Point> = new ObjectSet(point.equals, point.hashCode)\r\n\taddedPoint: ObjectSet<Point> = new ObjectSet(point.equals, point.hashCode)\r\n\r\n\tprivate async searchPolygon(): Promise<Array<Array<Point>>> {\r\n\t\tvar loopTime = performance.now();\r\n\t\tvar promise: Array<Promise<void>> = [];\r\n\t\tvar list = this.traverse(this.list, promise);\r\n\t\tlist.forEach(node => node.onSolved(this.targetLevel));\r\n\t\tthis.result.push(list);\r\n\t\tthis.list = list;\r\n\t\tawait Promise.all(promise);\r\n\r\n\t\tconsole.log(`execute index:${this.targetLevel} time:${performance.now() - loopTime}`);\r\n\t\tif (this.callback && this.list) {\r\n\t\t\tthis.callback(this.targetLevel - 1, this.list);\r\n\t\t}\r\n\t\tconst nextLevel = this.targetLevel + 1;\r\n\t\tif (nextLevel <= this.level) {\r\n\t\t\tthis.targetLevel = nextLevel;\r\n\t\t\treturn this.searchPolygon();\r\n\t\t} else {\r\n\t\t\tthis.bisectors.forEach(b => b.release());\r\n\t\t\tconsole.log(`execute done. time:${performance.now() - this.time}`);\r\n\r\n\t\t\tthis.running = false;\r\n\r\n\t\t\treturn this.result;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tprivate traverse(list: Array<Node> | null, tasks: Array<Promise<void>>) {\r\n\t\tvar next: Node | null = null\r\n\t\tvar previous: Node | null = null\r\n\t\tif (!list) {\r\n\t\t\tvar history = new ObjectSet(point.equals, point.hashCode);\r\n\t\t\tvar sample = this.bisectors[0];\r\n\t\t\tnext = sample.intersections[1].node;\r\n\t\t\tprevious = sample.intersections[0].node;\r\n\t\t\twhile (history.add(next)) {\r\n\t\t\t\tvar current: Node = next;\r\n\t\t\t\tnext = current.nextDown(previous);\r\n\t\t\t\tprevious = current;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tprevious = list[list.length - 1];\r\n\t\t\tfor (let n of list) {\r\n\t\t\t\tnext = n.nextUp(previous);\r\n\t\t\t\tprevious = n;\r\n\t\t\t\tif (next && !next.hasSolved()) break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!next || !previous || next.hasSolved()) {\r\n\t\t\tthrow new VoronoiError(\"fail to traverse polygon\");\r\n\t\t}\r\n\r\n\t\tvar start = next;\r\n\t\tlist = [start];\r\n\t\twhile (true) {\r\n\t\t\tthis.requestExtension(next.p1.line.delaunayPoint, tasks);\r\n\t\t\tthis.requestExtension(next.p2.line.delaunayPoint, tasks);\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current.next(previous);\r\n\t\t\tprevious = current;\r\n\t\t\tif (point.equals(start, next)) break;\r\n\t\t\tlist.push(next);\r\n\t\t}\r\n\r\n\t\treturn list;\r\n\t}\r\n\r\n\tprivate requestExtension(target: Point | null, tasks: Array<Promise<void>>): void {\r\n\t\tif (target && this.requestedPoint.add(target)) {\r\n\t\t\tvar task = this.provider(target).then(neighbors => {\r\n\t\t\t\tfor (let p of neighbors) {\r\n\t\t\t\t\tif (this.addedPoint.add(p)) {\r\n\t\t\t\t\t\tthis.addBisector(p);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\ttasks.push(task);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * @param {*} self Line \r\n\t */\r\n\tprivate addBoundary(self: Line): void {\r\n\t\tvar boundary = new Bisector(self);\r\n\t\tthis.bisectors.forEach(preexist => {\r\n\t\t\tvar p = line.getIntersection(boundary.line, preexist.line);\r\n\t\t\tif (!p) throw new VoronoiError(\"intersection not found\")\r\n\t\t\tvar a = new Intersection(p, boundary);\r\n\t\t\tvar b = new Intersection(p, preexist);\r\n\t\t\tvar n = new Node(p, a, b);\r\n\t\t\ta.node = n;\r\n\t\t\tb.node = n;\r\n\t\t\tboundary.addIntersection(a);\r\n\t\t\tpreexist.addIntersection(b);\r\n\t\t});\r\n\t\tthis.bisectors.push(boundary);\r\n\t}\r\n\r\n\tprivate addBisector(intersection: Point) {\r\n\t\tvar bisector = new Bisector(\r\n\t\t\tline.getPerpendicularBisector(intersection, this.center),\r\n\t\t\tintersection\r\n\t\t);\r\n\t\tthis.bisectors.forEach(preexist => {\r\n\t\t\tvar p = line.getIntersection(bisector.line, preexist.line);\r\n\t\t\tif (p && triangle.containsPoint(this.container, p, ERROR)) {\r\n\t\t\t\tvar a = new Intersection(p, bisector, preexist.line, this.center);\r\n\t\t\t\tvar b = new Intersection(p, preexist, bisector.line, this.center);\r\n\t\t\t\tvar n = new Node(p, a, b);\r\n\t\t\t\ta.node = n;\r\n\t\t\t\tb.node = n;\r\n\t\t\t\tbisector.addIntersection(a);\r\n\t\t\t\tpreexist.addIntersection(b);\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis.bisectors.push(bisector);\r\n\t}\r\n\r\n\r\n\r\n}","import * as line from \"./Line\";\nimport * as point from \"./Point\";\nimport * as edge from \"./Edge\";\nimport * as circle from \"./Circle\";\nimport {Point, Line, Edge, Triangle, Circle, DiagramError} from \"./types\"\n\nclass TriangleInitError extends DiagramError {}\n\nexport function init(a: Edge | Point,b: Point,c?: Point): Triangle{\n\tif ( edge.isEdge(a) ){\n\t\tvar e = a;\n\t\tc = b;\n\t\tb = e.b;\n\t\ta = e.a;\n\t}\n\tif ( c ){\n\n\t\tif ( line.onLine(a,b,c) ) {\n\t\t\tthrow new TriangleInitError(`points are on the same line. a:${point.toString(a)} b:${point.toString(b)} c:${point.toString(c)}`)\n\t\t}\n\t\tvar array = [a,b,c].sort(point.compare);\n\t\treturn {\n\t\t\ta: array[0],\n\t\t\tb: array[1],\n\t\t\tc: array[2],\n\t\t};\n\t}\n\tthrow new TriangleInitError(\"invalid arguments\")\n}\n\n/**\n * 同値判定\n * @param {triangle} self \n * @param {triangle} other \n */\nexport function equals(self: Triangle,other: Triangle): boolean{\n\treturn point.equals(self.a,other.a) && point.equals(self.b,other.b) && point.equals(self.c, other.c);\n}\n\nexport function hashCode(t: Triangle): number{\n\tvar hash = 17;\n\thash = 31 * hash + point.hashCode(t.a);\n\thash = 31 * hash + point.hashCode(t.b);\n\thash = 31 * hash + point.hashCode(t.c);\n\treturn hash & hash;\n}\n\n/**\n * 三角形との交点をすべて取得する\n * @param {triangle} triangle \n * @param {line/edge} line \n * @return {array} Pointの自然順序付けに従いソートされた交点のリスト 0 <= array.length <= 3\n */\nexport function getIntersection(triangle: Triangle,ln: Line): Array<Point>{\n\tvar ab = edge.init(triangle.a, triangle.b);\n\tvar bc = edge.init(triangle.b, triangle.c);\n\tvar ca = edge.init(triangle.c, triangle.a);\n\treturn [ab,bc,ca]\n\t\t.map( e => edge.getIntersection(e, ln) )\n\t\t.filter( (p: Point | null): p is Point => p !== null )\n\t\t.sort(point.measure);\n}\n\nexport function getOppositeSide(triangle: Triangle, p: Point): Edge{\n\tif ( point.equals(triangle.a, p) ){\n\t\treturn edge.init(triangle.b, triangle.c);\n\t} else if ( point.equals(triangle.b, p) ){\n\t\treturn edge.init(triangle.c, triangle.a);\n\t} else if ( point.equals(triangle.c, p) ){\n\t\treturn edge.init(triangle.a, triangle.b);\n\t} else {\n\t\tthrow new DiagramError(\"point is not any vertex of a triangle\")\n\t}\n}\n\nexport function containsPoint(triangle: Triangle, p: Point, error: number = 0.0): boolean {\n\tvar x1 = triangle.a.x - p.x;\n\tvar y1 = triangle.a.y - p.y;\n\tvar x2 = triangle.b.x - p.x;\n\tvar y2 = triangle.b.y - p.y;\n\tvar x3 = triangle.c.x - p.x;\n\tvar y3 = triangle.c.y - p.y;\n\tvar v1 = x1 * y2 - y1 * x2;\n\tvar v2 = x2 * y3 - y2 * x3;\n\tvar v3 = x3 * y1 - y3 * x1;\n\tif ( error && error > 0 ){\n\t\treturn (v1 > -error && v2 > -error && v3 > -error ) \n\t\t\t|| (v1 < error && v2 < error && v3 < error);\n\t} else {\n\t\treturn (v1 >= 0 && v2 >= 0 && v3 >= 0) || (v1 <= 0 && v2 <= 0 && v3 <= 0);\n\n\t}\n}\n\nexport function isVertex(triangle: Triangle ,p: Point): boolean{\n\treturn point.equals(triangle.a,p) || point.equals(triangle.b,p) || point.equals(triangle.c,p);\n}\n\nexport function isEdge(triangle: Triangle, e: Edge): boolean{\n\treturn isVertex(triangle,e.a) && isVertex(triangle,e.b);\n}\n\nexport function hasSameVertex(self: Triangle, other: Triangle): boolean{\n\treturn isVertex(self, other.a) || isVertex(self, other.b) || isVertex(self, other.c);\n}\n\nexport function getCircumscribed(triangle: Triangle): Circle{\n\tconst a = triangle.a;\n\tconst b = triangle.b;\n\tconst c = triangle.c;\n\tvar cc = 2 * ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\n\tif ( cc === 0 ) {\n\t\tthrow new circle.CircleError(\"triangle too small\")\n\t}\n\t//http://tercel-sakuragaoka.blogspot.jp/2011/06/processingdelaunay_3958.html\n\tvar p = b.x * b.x - a.x * a.x + b.y * b.y - a.y * a.y;\n\tvar q = c.x * c.x - a.x * a.x + c.y * c.y - a.y * a.y;\n\tvar center = {\n\t\tx: ((c.y - a.y) * p + (a.y - b.y) * q) / cc,\n\t\ty: ((a.x - c.x) * p + (b.x - a.x) * q) / cc\n\t};\n\tvar r = point.measure(center, a);\n\treturn circle.init(center, r);\n}","import { Voronoi } from \"../diagram/Voronoi\"\r\nimport { Point } from \"../diagram/types\"\r\n\r\nconst ctx: Worker = self as any;  /* eslint-disable-line no-restricted-globals */\r\n\r\ninterface WorkerState {\r\n\tvoronoi: Voronoi | null\r\n\tpromise: Map<number, ((p: Point[]) => void)>\r\n}\r\n\r\nconst state: WorkerState = {\r\n\tvoronoi: null,\r\n\tpromise: new Map(),\r\n};\r\n\r\nctx.addEventListener('message', messaage => {\r\n\tvar data = JSON.parse(messaage.data);\r\n\tconsole.log(\"worker\", data);\r\n\tif (data.type === 'start') {\r\n\t\tvar container = data.container;\r\n\t\tvar provider = function (point) {\r\n\t\t\treturn new Promise<Point[]>((resolve, reject) => {\r\n\t\t\t\tstate.promise.set(point.code, resolve);\r\n\t\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\t\ttype: 'points',\r\n\t\t\t\t\tcode: point.code,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\t\t};\r\n\t\tvar progress = (index: number, polygon: Point[]) => {\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'progress',\r\n\t\t\t\tindex: index,\r\n\t\t\t\tpolygon: polygon.map(point => {\r\n\t\t\t\t\treturn { lat: point.y, lng: point.x };\r\n\t\t\t\t})\r\n\t\t\t}));\r\n\t\t}\r\n\t\tstate.voronoi = new Voronoi(container, provider);\r\n\t\tstate.voronoi.execute(data.k, data.center, progress).then(() => {\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'complete',\r\n\t\t\t}));\r\n\t\t}).catch(e => {\r\n\t\t\tconsole.log(e)\r\n\t\t\tctx.postMessage(JSON.stringify({\r\n\t\t\t\ttype: 'error',\r\n\t\t\t\terr: e.message\r\n\t\t\t}));\r\n\t\t})\r\n\r\n\r\n\t} else if (data.type === 'points') {\r\n\t\tvar resolve = state.promise.get(data.code);\r\n\t\tif (resolve) {\r\n\t\t\tstate.promise.delete(data.code);\r\n\t\t\tresolve(data.points);\r\n\t\t} else {\r\n\t\t\tthrow new Error(`no promise code:${data.code}`);\r\n\t\t}\r\n\t}\r\n});"],"sourceRoot":""}